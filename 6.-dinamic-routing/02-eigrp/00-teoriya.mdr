# Теория

Теперь чуть ближе к теории работы:

Каждый процесс EIGRP обслуживает 3 таблицы:  
— Таблицу соседей \(neighbor table\), в которой содержится информация о “соседях”, т.е. других маршрутизаторах, непосредственно подключенных к текущему и участвующих в обмене маршрутами. Можно посмотреть с помощью команды **show ip eigrp neighbors**  
— Таблицу топологии сети \(topology table\), в которой содержится информация о маршрутах, полученная от соседей. Смотрим командой **show ip eigrp topology**  
— Таблицу маршрутизации \(routing table\), на основе которой роутер принимает решения о перенаправлении пакетов. Просмотр через **show ip route**

Метрика.  
Для оценки качества определенного маршрута, в протоколах маршрутизации используется некое число, отражающее различные его характеристики или совокупность характеристик- метрика. Характеристики, принимаемые в расчет, могут быть разными- начиная от количества роутеров на данном маршруте и заканчивая средним арифметическим загрузки всех интерфейсов по ходу маршрута. Что касается метрики EIGRP, процитируем Jeremy Cioara: “у меня создалось впечатление, что создатели EIGRP, окинув критическим взглядом свое творение, решили, что все слишком просто и хорошо работает. И тогда они придумали формулу метрики, что бы все сказали “ВАУ, это действительно сложно и профессионально выглядит”. Узрите же полную формулу подсчета метрики EIGRP: \(K1 _bw + \(K2_ bw\) / \(256 — load\) + K3 _delay\)_ \(K5 / \(reliability + K4\)\), в которой:  
— bw это не просто пропускная способность, а \(10000000/самая маленькая пропускная способность по дороге маршрута в килобитах\) _256  
— delay это не просто задержка, а сумма всех задержек по дороге в **десятках микросекунд**_ 256 \(delay в командах show interface, show ip eigrp topology и прочих показывается в микросекундах!\)  
— K1-K5 это коэффициенты, которые служат для того, чтобы в формулу “включился” тот или иной параметр.

Страшно? было бы, если бы все это работало, как написано. На деле же из всех 4 возможных слагаемых формулы, по умолчанию используются только два: bw и delay \(коэффициенты K1 и K3=1, остальные нулю\), что сильно ее упрощает — мы просто складываем эти два числа \(не забывая при этом, что они все равно считаются по своим формулам\). Важно помнить следующее: метрика считается по **худшему показателю пропускной способности по всей длине маршрута**.  
Если K5=0, то используется следующая формула: Metric = \(K1 _bw + \(K2_ bw\) / \(256 — load\) + \(K3 \* delay\)

> Интересная штука получилась с MTU: довольно часто можно встретить сведения о том, что MTU имеет отношение к метрике EIGRP. И действительно, значения MTU передаются при обмене маршрутами. Но, как мы можем видеть из полной формулы, никакого упоминания об MTU там нет. Дело в том, что этот показатель принимается в расчет в довольно специфических случаях: например, если роутер должен отбросить один из равнозначных по остальным характеристикам маршрутов, он выберет тот, у которого меньший MTU. Хотя, [не все так просто](http://blog.ioshints.info/2010/06/eigrp-mtu-metric.html) \(см. комментарии\).

Определимся с терминами, применяемыми внутри EIGRP. Каждый маршрут в EIGRP характеризуется двумя числами: Feasible Distance и Advertised Distance \(вместо Advertised Distance иногда можно встретить Reported Distance, это одно и то же\). Каждое из этих чисел представляет собой метрику, или стоимость \(чем больше-тем хуже\) данного маршрута с разных точек измерения: FD это “от меня до места назначения”, а AD- “от соседа, который мне рассказал об этом маршруте, до места назначения”. Ответ на закономерный вопрос “Зачем нам надо знать стоимость от соседа, если она и так включена в FD?”- чуть ниже \(пока можете остановиться и поломать голову сами, если хотите\).

У каждой подсети, о которой знает EIGRP, на каждом роутере существует Successor- роутер из числа соседей, через который идет лучший \(с меньшей метрикой\), по мнению протокола, маршрут к этой подсети. Кроме того, у подсети может также существовать один или несколько запасных маршрутов \(роутер-сосед, через которого идет такой маршрут, называется Feasible Successor\). EIGRP- единственный протокол маршрутизации, запоминающий запасные маршруты \(в OSPF они есть, но содержатся, так сказать, в “сыром виде” в таблице топологии- их еще надо обработать алгоритмом SPF\), что дает ему плюс в быстродействии: как только протокол определяет, что основной маршрут \(через successor\) недоступен, он сразу переключается на запасной. Для того, чтобы роутер мог стать feasible successor для маршрута, его AD должно быть меньше FD successor’а этого маршрута \(вот зачем нам нужно знать AD\). Это правило применяется для того, чтобы избежать колец маршрутизации.

Предыдущий абзац взорвал мозг? Материал трудный, поэтому еще раз на примере. У нас есть вот такая сеть:

![](http://img-fotki.yandex.ru/get/6419/83739833.20/0_9e454_30108738_L.jpg)

С точки зрения R1, R2 является Successor’ом для подсети 192.168.2.0/24. Чтобы стать FS для этой подсети, R4 требуется, чтобы его AD была меньше FD для этого маршрута. FD у нас \(\(10000000/1544\)_256\)+\(2100\_256\) =2195456, AD у R4 \(с его точки зрения это FD, т.е. сколько ему стоит добраться до этой сети\) = \(\(10000000/100000\)\_256\)+\(100\_256\)=51200. Все сходится, AD у R4 меньше, чем FD маршрута, он становится FS._ тут мозг такой и говорит: “БДЫЩЬ”\_. Теперь смотрим на R3- он анонсирует свою сеть 192.168.1.0/24 соседу R1, который, в свою очередь, рассказывает о ней своим соседям R2 и R4. R4 не в курсе, что R2 знает об этой подсети, и решает ему рассказать. R2 передает информацию о том, что он имеет доступ через R4 к подсети 192.168.1.0/24 дальше, на R1. R1 строго смотрит на FD маршрута и AD, которой хвастается R2 \(которая, как легко понять по схеме, будет явно больше FD, так как включает и его тоже\) и прогоняет его, чтобы не лез со всякими глупостями. Такая ситуация довольно маловероятна, но может иметь место при определенном стечении обстоятельств, например, при отключении механизма “расщепления горизонта” \(split-horizon\). А теперь к более вероятной ситуации: представим, что R4 подключен к сети 192.168.2.0/24 не через FastEthernet, а через модем на 56k \(задержка для dialup составляет 20000 usec\), соответственно, добраться ему стоит \(\(10000000/56\)\_256\)+\(2000\_256\)= 46226176. Это больше, чем FD для этого маршрута, поэтому R4 не станет Feasible Successor’ом. Но это не значит, что EIGRP вообще не будет использовать данный маршрут. Просто переключение на него займет больше времени \(подробнее об этом дальше\).

## Соседство

Роутеры не разговаривают о маршрутах с кем попало — прежде чем начать обмениваться информацией, они должны установить отношения соседства. После включения процесса командой router eigrp с указанием номера автономной системы, мы, командой network говорим, какие интерфейсы будут участвовать и одновременно, информацию о каких сетях мы желаем распространять. Незамедлительно, через эти интерфейсы начинают рассылаться hello-пакеты на мультикаст- адрес 224.0.0.10 \(по умолчанию каждые 5 секунд для ethernet\). Все маршрутизаторы с включенным EIGRP получают эти пакеты, далее каждый маршрутизатор-получатель делает следующее:  
— сверяет адрес отправителя hello-пакета, с адресом интерфейса, из которого получен пакет, и удостоверяется, что они из одной подсети  
— сверяет значения полученных из пакета K-коэффициентов \(проще говоря, какие переменные используются в подсчете метрики\) со своими. Понятно, что если они различаются, то метрики для маршрутов будут считаться по разным правилам, что недопустимо  
— проверяет номер автономной системы  
— опционально: если настроена аутентификация, проверяет соответствие ее типа и ключей.

Если получателя все устраивает, он добавляет отправителя в список своих соседей, и посылает ему \(уже юникастом\) update-пакет, в котором содержится список всех известных ему маршрутов \(aka full-update\). Отправитель, получив такой пакет, в свою очередь, делает то же самое. Для обмена маршрутами EIGRP использует Reliable Transport Protocol \(RTP, не путать с Real-time Transport Protocol, который используется в ip-телефонии\), который подразумевает подтверждение о доставке, поэтому каждый из роутеров, получив update- пакет, отвечает ack -пакетом \(сокращение от acknowledgement- подтверждение\). Итак, отношение соседства установлены, роутеры узнали друг у друга исчерпывающую информацию о маршрутах, что дальше? Дальше они будут продолжать посылать мультикаст hello-пакеты в подтверждение того, что они на связи, а в случае изменения топологии- update-пакеты, содержащие сведения только об изменениях \(partial update\).

Теперь вернемся к предыдущей схеме с модемом.

![](http://img-fotki.yandex.ru/get/6423/83739833.20/0_9ed88_746dfb1e_XL.jpg)

R2 по каким-то причинам потерял связь с 192.168.2.0/24. До этой подсети у него нет запасных маршрутов \(т.е. отсутствует FS\). Как всякий ответственный роутер с EIGRP, он хочет восстановить связь. Для этого он начинает рассылать специальные сообщения \(query- пакеты\) всем своим соседям, которые, в свою очередь, не находя нужного маршрута у себя, расспрашивают всех своих соседей, и так далее. Когда волна запросов докатывается до R4, он говорит “погодите-ка, у меня есть маршрут к этой подсети! Плохонький, но хоть что-то. Все про него забыли, а я-то помню”. Все это он упаковывает в reply-пакет и отправляет соседу, от которого получил запрос \(query\), и дальше по цепочке. Понятное дело, это все занимает больше времени, чем просто переключение на Feasible Successor, но, в итоге, мы получаем связь с подсетью.

А сейчас опасный момент: может, вы уже обратили внимание и насторожились, прочитав момент про эту веерную рассылку. Падение одного интерфейса вызывает нечто похожее на широковещательный шторм в сети \(не в таких масштабах, конечно, но все-таки\), причем чем больше в ней роутеров, тем больше ресурсов потратится на все эти запросы-ответы. Но это еще пол-беды. Возможна ситуация и похуже: представим, что роутеры, изображенные на картинке- это только часть большой и распределенной сети, т.е. некоторые могут находится за много тысяч километров от нашего R2, на плохих каналах и прочее. Так вот, беда в том, что, послав query соседу, роутер обязан дождаться от него reply. Неважно, что в ответе- но он должен прийти. Даже если роутер **уже** получил положительный ответ, как в нашем случае, он не может поставить этот маршрут в работу, пока не дождется ответа на все свои запросы. А запросы-то, может, еще где-нибудь на Аляске бродят. Такое состояние маршрута называется stuck-in-active. Тут нам нужно познакомится с терминами, отражающими состояние маршрута в EIGRP: active\passive route. Обычно они вводят в заблуждение. Здравый смысл подсказывает, что active значит маршрут “активен”, включен, работает. Однако тут все наоборот: passive это “все хорошо”, а состояние active означает, что данная подсеть недоступна, и маршрутизатор находится в активном поиске другого маршрута, рассылая query и ожидая reply. Так вот, состояние stuck-in-active \(застрял в активном состоянии\) может продолжатся до 3 минут! По истечение этого срока, роутер обрывает отношения соседства с тем соседом, от которого он не может дождаться ответа, и может использовать новый маршрут через R4. [Подробно о проблеме](http://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a008010f016.shtml)

История, леденящая кровь сетевого инженера. 3 минуты даунтайма это не шутки. Как мы можем избежать инфаркта этой ситуации? Выхода два: суммирование маршрутов и так называемая stub-конфигурация.

> Вообще говоря, есть еще один выход, и он называется фильтрация маршрутов \(route filtering\). Но это настолько объемная тема, что можно отдельную статью под нее писать, а у нас и так уже пол-книги получилось в этот раз. Поэтому на ваше усмотрение.

Как мы уже упоминали, в EIGRP суммирование маршрутов можно проводить на любом роутере. Для иллюстрации, представим, что к нашему многострадальному R2 подключены подсети от 192.168.0.0/24 до 192.168.7.0/24, что очень удобненько суммируется в 192.168.0.0/21 \(вспоминаем [binary math](http://habrahabr.ru/post/129664/)\). Роутер анонсирует этот суммарный маршрут, и все остальные знают: если адрес назначения начинается на 192.168.0-7, то это к нему. Что будет происходить, если одна из подсетей пропадет? Роутер будет рассылать query-пакеты с адресом этой сети \(конкретным, например, 192.168.5.0/24\), но соседи, вместо того, чтобы уже от своего имени продолжить порочную рассылку, будут сразу в ответ слать отрезвляющие реплаи, мол, это твоя подсеть, ты и разбирайся.

Второй вариант- stub- конфигурация. Образно говоря, stub означает “конец пути”, “тупик” в EIGRP, т.е., чтобы попасть в какую-то подсеть, не подключенную **напрямую** к такому роутеру, придется идти назад. Роутер, сконфигурированный, как stub, не будет пересылать трафик между подсетями, которые ему стали известны от EIGRP \(проще говоря, которые в show ip route помечены буквой D\). Кроме того, его соседи не будут отправлять ему query-пакеты. Самый распространенный случай применения- hub-and-spoke топологии, особенно с избыточными линками. Возьмем такую сеть: слева- филиалы, справа- основной сайт, главный офис и т.п. Для отказоустойчивости избыточные линки. Запущен EIGRP с дефолтными настройками.

![](http://img-fotki.yandex.ru/get/6423/83739833.20/0_9eab6_728d6664_XL.jpg)

А теперь “внимание, вопрос”: что будет, если R1 потеряет связь с R4, а R5 потеряет LAN? Трафик из подсети R1 в подсеть главного офиса будет идти по маршруту R1-&gt;R5-&gt;R2\(или R3\)-&gt;R4. Будет это эффективно? Нет. Будет страдать не только подсеть за R1, но и подсеть за R2 \(или R3\), из-за увеличения объемов трафика и его последствий. Вот для таких-то ситуаций и придуман stub. За роутерами в филиалах нет других роутеров, которые вели бы в другие подсети, это “конец дороги”, дальше только назад. Поэтому мы с легким сердцем можем сконфигурировать их как stub’ы, что, во-первых, избавит нас от проблемы с “кривым маршрутом”, изложенной чуть выше, а во-вторых, от флуда query-пакетов в случае потери маршрута.

Существуют различные режимы работы stub-роутера, задаются они командой eigrp stub:

> R1\(config\)\#router eigrp 1  
> R1\(config-router\)\#eigrp stub?  
> connected Do advertise connected routes  
> leak-map Allow dynamic prefixes based on the leak-map  
> receive-only Set IP-EIGRP as receive only neighbor  
> redistributed Do advertise redistributed routes  
> static Do advertise static routes  
> summary Do advertise summary routes

По умолчанию, если просто дать команду eigrp stub, включаются режимы сonnected и summary. Интерес представляет режим receive-only, в котором роутер не анонсирует никаких сетей, только слушает, что ему говорят соседи \(в RIP есть команда passive interface, которая делает то же самое, но в EIGRP она полностью отключает протокол на выбранном интерфейсе, что не позволяет установить соседство\).

Важные моменты в теории EIGRP, не попавшие в статью:

* В EIGRP можно настроить [аутентификацию](http://www.cisco.com/en/US/tech/tk365/technologies_configuration_example09186a00807f5a63.shtml) соседей
* Концепция [graceful shutdown](http://blog.ioshints.info/2007/03/eigrp-goodbye-message.html)
* [Балансировка нагрузки](http://www.cisco.com/en/US/tech/tk365/technologies_tech_note09186a008009437d.shtml)

