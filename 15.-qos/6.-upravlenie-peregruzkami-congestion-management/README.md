# 6. Управление перегрузками

Когда всё плохо, приоритет обработки следует отдать более важному трафику. Важность каждого пакета определяется на этапе классификации.

Но что такое плохо?  
Необязательно все буферы должны быть забиты, чтобы приложения начали испытывать проблемы.  
Самый простой пример — голосовые пакетики, которые толпятся за большими пачками крупных пакетов приложения, скачивающего файл.  
Это увеличит задержку, испортит джиттер и, возможно, вызовет отбрасывания.  
То есть мы имеем проблемы с обеспечением качественных услуг при фактическом отсутствии перегрузок.  
Эту проблему призван решить механизм управления перегрузками \(Congestion Management\).  
Трафик разных приложений разделяется по очередям, как мы уже видели выше.  
Вот только в результате всё снова должно слиться в один интерфейс. Сериализация всё равно происходит последовательно.  
Каким же образом разным очередям удаётся предоставлять различный уровень сервисов?  
По-разному изымать пакеты из разных очередей.  
Занимается этим **диспетчер** \(**schedler**\).

Мы рассмотрим большинство существующих сегодня диспетчеров, начиная с самого простого:

* [**FIFO**](0-fifo-first-in-first-out.md) — только одна очередь, все в BE, С — несправедливость.
* [**PQ**](1-pq-priority-queuing.md) — дорогу олигархам, холопы уступают.
* [**FQ**](2-fq-fair-queuing.md) — все равны.
* [**RR**](3-rr-round-robin.md) **-** все равны только на бумаге
* **WFQ, DWRR** — все равны, но некоторые ровнее.

