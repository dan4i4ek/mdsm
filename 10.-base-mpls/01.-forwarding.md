# Передача трафика в сети MPLS

Сам по себе чистый MPLS применяется редко. Выигрыш в производительности незначительный, потому что разница между тем, чтобы заглянуть в FIB/поменять некоторые поля в заголовках и посмотреть таблицу меток/поменять метку в заголовке MPLS не такая уж большая. Используются, конечно, его приложения, перечисленные выше.  
Но в этой статье мы всё-таки сконцентрируемся именно на чистом MPLS, чтобы понимать как это работает в самом базовом виде.  
[Ниже мы рассмотрим](03.-label_distribution/01.-protocols/01.-mpls_bgp.md) также одно применение чистого MPLS.

Несмотря на то, что MPLS не привязывается к типу сети, на которой он будет работать, в наше время он живёт в симбиозе только с IP. То есть сама сеть строится поверх IP, но переносить при этом она может данные многих других протоколов.  
Но давайте уже перейдём к сути, и сначала я хочу сказать, что **MPLS не заменяет IP-маршрутизацию**, а работает поверх неё.

Чтобы быть более конкретным, я возьму такую сеть.

![](../.gitbook/assets/0_100a2c_2b3d829b_orig-1.png)

Сейчас она в полностью рабочем состоянии, но без всяких намёков на MPLS. То есть R1, например, видит R6 и может пинговать его Loopback.  
ПК1 посылает ICMP-запрос на сервер 172.16.0.2. ICMP-запрос — это IP-пакет. На R1 согласно базовым принципам пакет уходит через интерфейс FE0/0 на R2 — так сказала Таблица Маршрутизации.  
R2 после получения пакета проверяет адрес назначения, просматривает свою FIB, видит следующий маршрутизатор и отправляет пакет в интерфейс FE0/0.  
И этот процесс повторяется раз за разом. Каждый маршрутизатор самостоятельно решает судьбу пакета.

Вот так совершенно привычно выглядит дамп трафика:

![](../.gitbook/assets/0_100966_fcc67b8b_orig.png)

Что происходит, если мы активируем MPLS? Вот сразу же, в ту же секунду мир меняется. После этого на маршрутизаторах заполняются таблицы меток и строятся многочисленные LSP.

И теперь тот же путь будет проделан немного иначе.

![](../.gitbook/assets/32cf205d34d648caa6ab8c2983f754db-1.gif)

Когда IP-пакет от ПК1 попадает в сеть MPLS первый маршрутизатор навешивает метку, дальше этот пакет идёт к точке назначения, а каждый следующий маршрутизатор меняет одну метку на другую. При выходе из сети MPLS метка снимается и дальше передаётся уже чистый IP-пакет, каким он был в самом начале.

Это основной принцип MPLS — маршрутизаторы коммутируют пакеты по меткам, не заглядывая внутрь пакета MPLS. Первый — добавляет, последний — удаляет.

Давайте рассмотрим шаг за шагом передачу пакета данных от ПК1 до узла назначения:

**1.** ПК1 — обычный компьютер — отправляет обычный пакет на удалённый сервер.

**2.** Пакет доходит до R1. Он добавляет метку 18. Она вставляется между заголовком IP и Ethernet.  
Эту информацию он может взять из FIB:

![](../.gitbook/assets/0_10096a_76d817ff_orig.png)

По FIB видно, что пакет с адресатом **6.6.6.6** нужно снабдить меткой **18** и отправить в интерфейс **FE0/0**.  
Собственно это он и делает: добавляет заголовок и прописывает в него 18:

![&#x414;&#x430;&#x43C;&#x43F; &#x43C;&#x435;&#x436;&#x434;&#x443; R1 &#x438; R2](../.gitbook/assets/image-179.png)

**3.** R2 получает этот пакет, в заголовке Ethernet видит, что это MPLS-пакет \(Ethertype 8847\), считывает метку и обращается к своей таблице меток:

![](../.gitbook/assets/0_100967_b461a856_orig-1.png)

![](../.gitbook/assets/0_10096b_bc8ed326_orig.png)

Читаем по буквам: если пакет MPLS пришёл с меткой 18, её нужно поменять на 20 и отправить пакет в интерфейс FE0/0.

![&#x414;&#x430;&#x43C;&#x43F; &#x43F;&#x43E;&#x441;&#x43B;&#x435; R2](../.gitbook/assets/image-191.png)

**4.** R5 совершает аналогичные действия — видит, что пришёл пакет с меткой 20, её нужно поменять на 0 и отправить в FE1/0. Без всякого обращения к таблице маршрутизации.

**5.** R6, получив пакет MPLS, видит в своей таблице, что теперь метку надо снять. А, сняв её, видит уже, что адресат пакета — 172.16.0.2 — это Directly Connected сеть. Дальше пакет передаётся обычным образом по таблице маршрутизации уже безо всяких меток.

**То есть целиком процесс выглядит так:**

![&#x41D;&#x435; &#x431;&#x443;&#x434;&#x435;&#x43C; &#x440;&#x430;&#x441;&#x441;&#x43C;&#x430;&#x442;&#x440;&#x438;&#x432;&#x430;&#x442;&#x44C; &#x43A;&#x43E;&#x43D;&#x435;&#x447;&#x43D;&#x44B;&#x435; &#x443;&#x437;&#x43B;&#x44B;, &#x447;&#x442;&#x43E;&#x431;&#x44B; &#x43D;&#x435; &#x443;&#x441;&#x43B;&#x43E;&#x436;&#x43D;&#x44F;&#x442;&#x44C; &#x441;&#x445;&#x435;&#x43C;&#x443;.](../.gitbook/assets/c316ae95bc8d4450a30e99e111354025.gif)

Пока, вроде, всё просто, пусть и непонятно зачем.

Сейчас домены IGP и MPLS совпадают и MPLS только обещает нам в дальнейшем какие-то плюшки: L2VPN, L3VPN, MPLS TE.  
Но, на самом деле, даже базовый MPLS дает нам преимущества, если мы вспомним, что мы провайдер.  
Как провайдер, мы ведь не используем протоколы IGP для маршрутизации между AS. Для этого мы используем BGP. И именно в связке с BGP станут понятны преимущества MPLS.  
Рассмотрим нашу сеть в связке с соседними AS:

![](../.gitbook/assets/0_100a4d_647bcf2c_xxl-1.png)

Из выпуска о BGP мы знаем, что **на каждом** маршрутизаторе в нашей AS должен быть настроен BGP. Иначе мы не сможем передавать трафик соседних AS и наших клиентов, через нашу AS. Каждый маршрутизатор должен знать все маршруты.

Но это было до MPLS!  
Когда в нашей сети настроен MPLS, нам больше не обязательно настраивать BGP на каждом маршрутизаторе в сети. Достаточно настроить его только на пограничных маршрутизаторах в AS, на тех, которые подключены к другим клиентам или провайдерам.

![](../.gitbook/assets/0_100a4b_f130e3b2_xxl-1.png)

Но это не все хорошие новости. Кроме того, что BGP теперь можно не настраивать на каждом маршрутизаторе в AS, маршрутизаторам также не нужно создавать метку для каждого префикса BGP. Достаточно знать как добраться до IP-адреса, который указан как next-hop. То есть, если сессия BGP настроена между Loopback0 R1 и Loopback0 R6, то в таблице меток ничего не изменится, даже если каждый из них передает по BGP сотни тысяч маршрутов:

Например, маршрутизатору R1 по BGP от маршрутизатора R6 пришло несколько маршрутов:

![](../.gitbook/assets/image-74%20%281%29.png)

Посмотрим как будут обрабатываться пакеты, которые идут в сеть 100.0.0.0/16:

![](https://img-fotki.yandex.ru/get/15590/83739833.48/0_100a4c_5335b60c_orig.png)

В выводе выше видно, что пакетам будет добавляться метка 27.  
И, если посмотреть в таблицу меток, то там нет меток для маршрутов, которые известны по BGP, но есть метка 27 и она соответствует 6.6.6.6/32. А это именно тот адрес, который мы видели в маршрутах, которые пришли по BGP от R6:

![](https://img-fotki.yandex.ru/get/15483/83739833.48/0_100a4e_cfdf9929_orig.png)

Пример настройки вы можете найти [ниже](03.-label_distribution/01.-protocols/01.-mpls_bgp.md).

Мы немного забежали вперед, но теперь, когда стало понятнее какие преимущества дает даже базовый MPLS, мы можем окунуться в понятийный аппарат в мире MPLS.

