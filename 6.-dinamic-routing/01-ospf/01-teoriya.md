# Теория-2

1\) Штиль. Состояние OSPF — **DOWN**  
В это короткое мгновение в сети ничего не происходит — все молчат.

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da15_c2a85553_XL.jpg)

2\) Поднимается ветер: маршрутизатор рассылает Hello-пакеты на мультикастный адрес [224.0.0.5](http://en.wikipedia.org/wiki/Multicast_address) со всех интерфейсов, где запущен OSPF. [TTL](http://ru.wikipedia.org/wiki/Time_to_live) таких сообщений равен одному, поэтому их получат только маршрутизаторы, находящиеся в том же сегменте сети. R1 переходит в состояние **INIT**.

![](http://img-fotki.yandex.ru/get/6422/83739833.1f/0_9da19_bcc4c3f8_XL.jpg)

В пакеты вкладывается следующая информация:

* Router ID
* Hello Interval
* Dead Interval
* Neighbors
* Subnet mask
* Area ID
* Router Priority
* Адреса DR и BDR маршрутизаторов
* Пароль аутентификации

Нас интересуют пока первые четыре или точнее вообще только Router ID и Neighbors.  
Сообщение Hello от маршрутизатора R1 несёт в себе его Router ID и не содержит Neighbors, потому что у него их пока нет.  
После получения этого мультикастного сообщения маршрутизатор R2 добавляет R1 в свою таблицу соседей \(если совпали все необходимые параметры\).

![](http://img-fotki.yandex.ru/get/6521/83739833.1f/0_9da1c_13dc8099_XL.jpg)

И отправляет на R1 уже юникастом новое сообщение Hello, где содержится Router ID этого маршрутизатора, а в списке Neigbors перечислены все его соседи. В числе прочих соседей в этом списке есть Router ID R1, то есть R2 уже считает его соседом.

![](http://img-fotki.yandex.ru/get/6620/83739833.1f/0_9da20_235302c3_XL.jpg)

3\) Дружба. Когда R1 получает это сообщение Hello от R2, он пролистывает список соседей и находит в нём свой собственный Router ID, он добавляет R2 в свой список соседей.

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da26_46263e45_XL.jpg)

Теперь R1 и R2 друг у друга во взаимных соседях — это означает, что между ними установлены отношения смежности и маршрутизатор R1 переходит в состояние **TWO WAY**.

![](http://img-fotki.yandex.ru/get/6421/83739833.1f/0_9da23_99cc98b_XL.jpg)

Далее происходит выбор [DR и BDR](http://ru.wikipedia.org/wiki/OSPF#.D0.92.D1.8B.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BC.D0.B0.D1.80.D1.88.D1.80.D1.83.D1.82.D0.B8.D0.B7.D0.B0.D1.82.D0.BE.D1.80_.28DR.29_.D0.B8_.D1.80.D0.B5.D0.B7.D0.B5.D1.80.D0.B2.D0.BD.D1.8B.D0.B9_.D0.B2.D1.8B.D0.B4.D0.B5.D0.BB.D0.B5.D0.BD.D0.BD.D1.8B.D0.B9_.D0.BC.D0.B0.D1.80.D1.88.D1.80.D1.83.D1.82.D0.B8.D0.B7.D0.B0.D1.82.D0.BE.D1.80_.28BDR.29), но мы не будем на этом останавливаться, хоть это и довольно важные вещи.

4\) Затишье перед бурей. Далее все переходят в состояние **EXSTART**. Здесь все соседи решают между собой, кто босс. Им становится маршрутизатор с наибольшим Router ID — R2.

5\) Когда выбран _Батька_, соседи переходят в состояние **Exchange** и обмениваются DBD-сообщениями \(или DD\) — Data Base Description, которые содержат описание LSDB \(Link State Data Base\), мол, я знаю про вот такие подсети.  
Тут надо пояснить, что такое LSDB. Если перевести на русский дословно: база данных о состоянии линков. В изначальном состоянии маршрутизатор знает только о тех линках \(интерфейсах\), на которых запущен процесс OSPF. По ходу пьесы, каждый маршрутизатор собирает всю информацию о сети и составляет топологию. Именно она и будет являться LSDB, которая должна быть одинакова на всех членах зоны.  
Первым отсылает свою DBD маршрутизатор, выбранный главным на данном интерфейсе — 2.2.2.2. Следом за ним то же делает и 1.1.1.1.

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da2a_2882c479_XL.jpg)

6\) Получив сообщение, маршрутизаторы R1 и R2 отправляют подтверждение о приёме DBD \(LSAck\), а затем сравнивают новую информацию с той, что содержится у них в LSDB и, если есть отличия, посылают LSR \(Link State Request\) друг другу, тем самым переходя в новое состояние **LOADING**. В LSR они говорят — “Я про вот эту сеть ничего не знаю. Расскажи мне подробнее”.

![](http://img-fotki.yandex.ru/get/6520/83739833.1f/0_9da2e_7c726edb_XL.jpg)

7\) R2, получив LSR от R1, высылает LSU \(Link State Update\), которые содержат в себе LSA \(Link State Advertisement\) c детальной информацией о нужных подсетях.

![](http://img-fotki.yandex.ru/get/6622/83739833.1f/0_9da32_4552fd75_XL.jpg)

И вот, как только R1 получит последнюю порцию данных о всех подсетях и сформирует свою LSDB, он переходит в своё конечное состояние **FULL STATE**.

![](http://img-fotki.yandex.ru/get/6623/83739833.1f/0_9da36_d2c831e1_XL.jpg)

К тому моменту, как все маршрутизаторы зоны придут к состоянию Full State на всех на них должна быть полностью одинаковая LSDB — они же одну и ту же сеть изучали. То есть фактически это означает, что маршрутизатор знает всю вашу сеть, что, как и куда подключено.

> Авторы осознают, что понять и запомнить все эти аббревиатуры и правила довольно сложно, но прочитав это 5 -7 раз в разных местах с некоторой периодичностью, можно будет составить представление о том, как OSPF работает.

8\) Итак, сейчас у нас все маршрутизаторы знают всё о сети, но это знание не помогает в маршрутизации.  
Следующим шагом OSPF, используя алгоритм Дейкстры \(или его ещё называют SPF — Shortest Path First\), вычисляет кратчайший маршрут до каждого маршрутизатора в зоне — он ведь знает всю топологию. В этом ему помогают метрики. Чем она ниже, тем маршрут лучше. Метрика — это стоимость движения по маршруту.

![](http://img-fotki.yandex.ru/get/6422/83739833.1f/0_9da0e_4fc28d4_XL.jpg)

Например, в такой сети из R1 в R3 можно добраться напрямую или через R2.  
Естественно первый вариант будет стоить меньше. Но это при условии, что у вас везде одинаковый тип интерфейсов. А если, например, между R1 и R3 у вас модемное соединение в 56к или крайне нестабильный GPRS линк? Тогда у них будет очень высокая стоимость и OSPF предпочтёт более длинный, но быстрый путь.  
Найденный путь потом добавляется в таблицу маршрутизации.

Теперь каждые 10 секунд каждый маршрутизатор будет отправлять Hello-пакеты, а каждые 30 минут рассылаются LSA — это типа данные уже считаются устаревшими, надо бы обновить, даже если изменений не было.

В идеальном мире на этом бы и установилось равновесие. Но мы живём в мире жестоком и равнодушном, где инженер — это итшник, а то и компьютерщик вообще, а лифты научились ездить вниз всего [три выпуска](https://github.com/djvnsk/SDSM/tree/f818dc762fe07ac77e90acf6b35cdea232ea4428/6.-dinamic-routing/01-ospf/3.-static_routing/README.md) назад. И в этом будничном мире кипят страсти: рвут оптику, вырубают питание, мыши перегрызают ножки процессоров \(или это не в этом мире?\) — иными словами, топология непрестанно меняется. И чем больше сеть, тем чаще и глобальнее изменения.

Разумеется, было бы несколько странно ждать 40 секунд \(Dead Interval\) и только потом начинать перестраивать таблицу. Это было бы простительно ещё RIP’у, но не протоколу, который используется в огромном количестве современных сетей. Итак, как только падает какой-либо из линков \(или несколько\), маршрутизатор изменяет свою LSDB и генерирует LSU, присваивая ей номер больше, чем он был прежде \(у каждой LSDB есть номер, который берётся из последнего полученного LSA\).

Это LSU сообщение рассылается на мультикастовый адрес 224.0.0.5. Маршрутизаторы получившие его, проверяют номер LSA, содержащихся в LSU.  
1\) Если номер больше, чем номер текущей LSA маршрутизатора — LSDB меняется. \(Версия LSDB старая, информация новая\),  
2\) Если номер такой же, ничего не происходит. Этот маршрутизатор уже получил данный LSA по какому-то другому пути,  
3\) Если номер полученного LSA меньше локальной LSDB, это означает, что у маршрутизатора уже более актуальная информация, и он посылает новый LSA \(на основе своей LSDB\) отправителю прежнего.

После произведённых \(или непроизведённых\) действий соседу, от которого пришёл LSU пересылаются LSAck \(мол, «посылку получили — всё в порядке»\), а другим соседям отправляется изначальный LSU без изменений. На данном маршрутизаторе снова запускается алгоритм SPF и, при необходимости, обновляется таблица маршрутизации.

В общем, всё это происходит в целях поддержания актуальности информации на всех устройствах — LSDB должна быть одинаковой у всех.

> Тут надо оговориться, что маршрутизатор замечает изменения только при прямом подключении к своему соседу. Если между ними будет, например, коммутатор, то устройство не обнаружит падения физического интерфейса и ничего не будет делать. Для таких ситуаций есть два решения.  
> 1\) Настроить таймеры. Для OSPF их можно уменьшить до уровня миллисекунд.  
> 2\) Использовать очень крутой протокол BFD \([Bidirectional Forwarding Detection](http://en.wikipedia.org/wiki/Bidirectional_Forwarding_Detection)\). Он позволяет отслеживать состояние линков также на миллисекундном уровне. В конфигурации BFD связывается с другими протоколами и позволяет очень быстро сообщить кому надо, что есть проблемы на сети. Конкретно с BFD мы будем разбираться в другой части.

Как вы заметили, на все сообщения есть подтверждения: либо это LSAck, либо ответ Hello на Hello. Это плата за отказ от TCP — как-то ведь надо убеждаться в успешной доставке.

> Всего существует 7 типов LSA, которые тесно завязаны на зоны, коих тоже 5 штук. Маршрутизаторы тоже бывают четырёх типов. А так же есть понятия Designated Router \(DR\) и Backup DR \(BDR\), ABR и ASBR. Есть формулы расчёт метрик и прочее, прочее. Оставляем это на самостоятельное изучение.

