# Route Distinguisher

Для того, чтобы различать маршруты различных VPN, обычный IPv4 префикс дополняется специальной приставкой длиной 8 байтов — **RD — Route Distinguisher**.

Тогда маршрут от C3PO будет выглядеть так: **64500:100:**10.10.10.10/32, а от TARS так: **64500:200:**10.10.10.10/32. И теперь это совершенно разные вещи, которые процесс BGP сможет друг от друга отличить.

Разберёмся что из себя представляет RD и как его определить.  
Существует 3 типа RD:  
![Типы RD](https://img-fotki.yandex.ru/get/21/83739833.55/0_10e8bc_74c4b913_orig.png)  
[_Навеяно_](http://packetlife.net/blog/2013/jun/10/route-distinguishers-and-route-targets/).

Первая часть — сам тип \(0, 1 или 2\);  
Вторая часть — Административное поле \(Administrator field\) — это всегда публичный параметр — публичный IP-адрес или публичный номер AS. Она необходима для того, чтобы ваши RD были уникальны не только в пределах сети, но и в пределах планеты.  
То есть в Административной части не должны появиться случайно IP адрес 172.16.127.2 или AS 65001. Это может пригодиться в том случае, когда VPN нужно передать в сеть другого провайдера \(а такое тоже не исключено в наше безумное время, и оно даже носит название Inter-AS VPN\).  
Третья часть — Выделенный номер \(Assigned Number\) — это уже то, что назначаете вы. Эта часть позволяет RD быть уникальным в пределах вашей сети и, собственно, определять VPN.

Как видите, RD уникальны в пределах планеты.

Вот два примера преобразования обычного IPv4-префикса 10.10.10.10/32 в VPNv4:

```text
0:64500:100:10.10.10.10/32
```

или

```text
1:100.0.0.1:100:10.10.10.10/32.
```

Какой выберете вы, не имеет значения, даже если в пределах сети вы будете использовать оба подхода одновременно. Даже для одного VRF на разных маршрутизаторах. Главная задача RD — разделить префиксы.  
То есть если совсем простым языком: совершенно не важно, что вы настроите, главное, чтобы вы были уверены, что BGP никогда не спутает маршруты разных VPN.  
Хотя систематизация ещё никому не мешала.

Обычно используют тип 0, Административное поле — это номер AS провайдера, а Выделенный номер вы выбираете самостоятельно. При настройке RD первые «0:» или «1:» \(тип RD\) сокращаются и получается так: _64500:100_ и _100.0.0.1:100_.  
Cisco позволяет использовать типы 0 и 1.

Да, RD придётся настроить вручную и самому следить за его уникальностью. Но по-другому тут и не получится — сами маршрутизаторы не умеют отслеживать, есть ли на других узлах уже такой RD или нет. А если и есть, то не тот же ли самый это VPN?

И что же у нас получается?

**1\)** Приходит от CE анонс новой сети. Пусть это будет 10.10.10.10/32, как мы и договаривались. PE добавляет этот маршрут в таблицу маршрутизации конкретного VRF. Заметьте, что в таблице маршрутизации хранится обычный IPv4 маршрут — никаких VPNv4. А это и не нужно: VRF изолированы друг от друга, как мы уже говорили раньше — это отдельный, пусть и виртуальный маршрутизатор.  
**2\)** BGP заметил, что появился новый префикс в VPN. Из конфигурации VRF он видит какой RD нужно использовать. Компилирует из RD и нового IPv4-префикса, VPNv4-префикс. Получается так:  
_C3PO: 64500:100:10.10.10.10/32_  
или так:  
_TARS: 64500:200:10.10.10.10/32_    

**3\)** Создавая BGP Update, маршрутизатор вставляет туда полученный VPNv4-префикс, адрес Next Hop и прочие атрибуты BGP. Но кроме всего прочего, он добавляет в поле NLRI информацию о **метке**. Эта метка привязана к маршруту, или точнее говоря, VPNv4-префикс — это FEC, а в NLRI передаётся связка данного FEC и метки.  
По-английски это называется **Labeled Route** — по-русски, пожалуй, _маршрут, снабжённый меткой_. Так данный PE уведомляет своих соседей, что если те получили от CE IP-пакет в эту сеть, ему нужно назначить такую **сервисную** метку.

![BGP Update с RD](https://img-fotki.yandex.ru/get/4603/83739833.55/0_10e8b3_6e7ce17b_orig.png)

Обратите также внимание на адрес Next Hop — это Loopback PE. И это очень правильно — Ingress PE должен знать, до какого Egress PE нужно отправить пришедший пакет с данными, то есть знать его Loopback, а дальше хоть потоп.

**4\)** Дальше BGP Update передаётся всем соседям, настроенным в секции VPNv4 family.

**5\)** Удалённый PE получает этот Update, видит в NLRI, что это не обычный IPv4 маршрут, а VPNv4. Помните, да: если придёт два маршрута в одну сеть от разных клиентов — они не перепутаются, потому что имеют разные RD. Далее Egress PE _определяет, в какой VRF этот маршрут нужно экспортировать_ и, собственно, делает это. Так маршрут появляется в таблице маршрутизации и FIB нужного VRF, а оттуда уходит в сеть клиента.

Теперь, когда PE получает от CE пакет с данными, который следует в сеть 10.10.10.10/32, в FIB этого VPN он находит сервисную метку \(22\) и Next-Hop \(1.1.1.1\). Инкапсулирует IP в MPLS, дальше ищет в уже глобальном FIB транспортную метку для Next Hop.  
Сама транспортная метка как и прежде доставляется протоколами LDP или RSVP-TE, а сервисная — MBGP.

Сравните поле NLRI в обычном BGP и в MP-BGP.  
![NLRI](https://img-fotki.yandex.ru/get/4104/83739833.55/0_10e8b4_f70d8262_orig.png)

![](https://habrastorage.org/files/bb5/f93/ae1/bb5f93ae1dd544319d7bdeec3a6b248c.gif)
