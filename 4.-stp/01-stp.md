# STP

Основная задача STP — предотвратить появление петель на втором уровне. Как это сделать? Да просто отрубить все избыточные линки, пока они нам не понадобятся. Тут уже сразу возникает много вопросов: какой линк из двух \(или трех-четырех\) отрубить? Как определить, что основной линк упал, и пора включать запасной? Как понять, что в сети образовалась петля? Чтобы ответить на эти вопросы, нужно разобраться, как работает STP.

STP использует алгоритм STA \(Spanning Tree Algorithm\), результатом работы которого является граф в виде дерева \(связный и без [простых циклов](http://ru.wikipedia.org/wiki/Граф_%28математика%29)\)

Для обмена информацией между собой свичи используют специальные пакеты, так называемые BPDU \(Bridge Protocol Data Units\). BPDU бывают двух видов: конфигурационные \(Configuration BPDU\) и панические “ААА, топология поменялась!” TCN \(Topology Change Notification BPDU\). Первые регулярно рассылаются корневым свичом \(и ретранслируются остальными\) и используются для построения топологии, вторые, как понятно из названия, отсылаются в случае изменения топологии сети \(проще говоря, подключении/отключении свича\). Конфигурационные BPDU содержат несколько полей, остановимся на самых важных:

* идентификатор отправителя \(Bridge ID\)
* идентификатор корневого свича \(Root Bridge ID\)
* идентификатор порта, из которого отправлен данный пакет \(Port ID\)
* стоимость маршрута до корневого свича \(Root Path Cost\)

Что все это такое и зачем оно нужно, объясню чуть ниже. Так как устройства не знают и не хотят знать своих соседей, никаких отношений \(смежности/соседства\) они друг с другом не устанавливают. Они шлют BPDU из всех работающих портов на мультикастовый ethernet-адрес **01-80-c2-00-00-00** \(по умолчанию каждые 2 секунды\), который прослушивают все свичи с включенным STP.

Итак, как же формируется топология без петель?

Сначала выбирается так называемый корневой мост/свич \(root bridge\). Это устройство, которое STP считает точкой отсчета, центром сети; все дерево STP сходится к нему. Выбор базируется на таком понятии, как идентификатор свича \(Bridge ID\). Bridge ID это число длиной 8 байт, которое состоит из Bridge Priority \(приоритет, от 0 до 65535, по умолчанию 32768+номер vlan или инстанс MSTP, в зависимости от реализации протокола\), и MAC-адреса устройства. В начале выборов каждый коммутатор считает себя корневым, о чем и заявляет всем остальным с помощью BPDU, в котором представляет свой идентификатор как ID корневого свича. При этом, если он получает BPDU с меньшим Bridge ID, он перестает хвастаться своим и покорно начинает анонсировать полученный Bridge ID в качестве корневого. В итоге, корневым оказывается тот свич, чей Bridge ID меньше всех.

{% hint style="warning" %}
Такой подход таит в себе довольно серьезную проблему. Дело в том, что, при равных значениях Priority \(а они равные, если не менять ничего\) корневым выбирается самый старый свич, так как мак адреса прописываются на производстве последовательно, соответственно, чем мак меньше, тем устройство старше \(естественно, если у нас все оборудование одного вендора\). Понятное дело, это ведет к падению производительности сети, так как старое устройство, как правило, имеет худшие характеристики. Подобное поведение протокола следует пресекать, выставляя значение приоритета на желаемом корневом свиче вручную, об этом в практической части.
{% endhint %}

## Роли портов

После того, как коммутаторы померились айдями и выбрали root bridge, каждый из остальных свичей должен найти один, и только один порт, который будет вести к корневому свичу. Такой порт называется **корневым портом \(Root port\)**. Чтобы понять, какой порт лучше использовать, каждый некорневой свич определяет стоимость маршрута от каждого своего порта до корневого свича. Эта стоимость определяется суммой стоимостей всех линков, которые нужно пройти кадру, чтобы дойти до корневого свича. В свою очередь, стоимость линка определяется просто — по его скорости \(чем выше скорость, тем меньше стоимость\). Процесс определения стоимости маршрута связан с полем BPDU “Root Path Cost” и происходит так:

* Корневой свич посылает BPDU с полем Root Path Cost, равным нулю
* Ближайший свич смотрит на скорость своего порта, куда BPDU пришел, и добавляет стоимость согласно таблице

| Скорость порта | Стоимость STP \(802.1d\) |
| :--- | :--- |
| 10 Mbps | 100 |
| 100 Mbps | 19 |
| 1 Gbps | 4 |
| 10 Gbps | 2 |

* Далее этот второй свич посылает этот BPDU нижестоящим коммутаторам, но уже с новым значением Root Path Cost, и далее по цепочке вниз

Если имеют место одинаковые стоимости \(как в нашем примере с двумя свичами и двумя проводами между ними — у каждого пути будет стоимость 19\) — корневым выбирается меньший \(fa01, а не fa12, к примеру\) порт.

Далее выбираются назначенные \(**Designated**\) порты. Из каждого конкретного сегмента сети должен существовать только один путь по направлению к корневому свичу, иначе это петля. В данном случае имеем в виду физический сегмент, в современных сетях без хабов это, грубо говоря, просто провод. Назначенным портом выбирается тот, который имеет лучшую стоимость в данном сегменте. У корневого свича все порты — назначенные.

И вот уже после того, как выбраны корневые и назначенные порты, оставшиеся блокируются, таким образом разрывая петлю.

![](https://habrastorage.org/getpro/habr/post_images/12d/06b/a31/12d06ba319526c38f704a50ad5480a17.jpg) На картинке маршрутизаторы выступают в качестве коммутаторов. В реальной жизни это можно сделать с помощью дополнительной свитчёвой платы.

### Состояния портов

Чуть раньше мы упомянули состояние блокировки порта, теперь поговорим о том, что это значит, и о других возможных состояниях порта в STP. Итак, в обычном \(802.1D\) STP существует 5 различных состояний:

* блокировка \(blocking\): блокированный порт не шлет ничего. Это состояние предназначено, как говорилось выше, для предотвращения петель в сети. Блокированный порт, тем не менее, слушает BPDU \(чтобы быть в курсе событий, это позволяет ему, когда надо, разблокироваться и начать работать\)
* прослушивание \(listening\): порт слушает и начинает сам отправлять BPDU, кадры с данными не отправляет.
* обучение \(learning\): порт слушает и отправляет BPDU, а также вносит изменения в CAM-таблицу, но данные не перенаправляет.
* перенаправление/пересылка \(forwarding\): этот может все: и посылает/принимает BPDU, и с данными оперирует, и участвует в поддержании таблицы mac-адресов. То есть это обычное состояние рабочего порта.
* отключен \(disabled\): состояние administratively down, отключен командой **shutdown**. Понятное дело, ничего делать не может вообще, пока вручную не включат.

Порядок перечисления состояний не случаен: при включении \(а также при втыкании нового провода\), все порты на устройстве с STP проходят вышеприведенные состояния именно в таком порядке \(за исключением disabled-портов\). Возникает закономерный вопрос: а зачем такие сложности? А просто STP осторожничает. Ведь на другом конце провода, который только что воткнули в порт, может быть свич, а это потенциальная петля. Вот поэтому порт сначала 15 секунд \(по умолчанию\) пребывает в состоянии прослушивания — он смотрит BPDU, попадающие в него, выясняет свое положение в сети — как бы чего ни вышло, потом переходит к обучению еще на 15 секунд — пытается выяснить, какие mac-адреса “в ходу” на линке, и потом, убедившись, что ничего он не поломает, начинает уже свою работу. Итого, мы имеем целых 30 секунд простоя, прежде чем подключенное устройство сможет обмениваться информацией со своими соседями. Современные компы грузятся быстрее, чем за 30 секунд. Вот комп загрузился, уже рвется в сеть, истерит на тему “DHCP-сервер, сволочь, ты будешь айпишник выдавать, или нет?”, и, не получив искомого, обижается и уходит в себя, извлекая из своих недр айпишник [автонастройки.](http://ru.wikipedia.org/wiki/APIPA) Естественно, после таких экзерсисов, в сети его слушать никто не будет, ибо “не местный” со своим 169.254.x.x. Понятно, что все это не дело, но как этого избежать?

### Portfast

Для таких случаев используется особый режим порта — portfast. При подключении устройства к такому порту, он, минуя промежуточные стадии, сразу переходит к forwarding-состоянию. Само собой, portfast следует включать только на интерфейсах, ведущих к конечным устройствам \(рабочим станциям, серверам, телефонам и т.д.\), но не к другим свичам.

{% hint style="info" %}
Есть очень удобная команда  режима конфигурации интерфейса для включения нужных фич на порту, в который будут включаться конечные 
устройства: **switchport host**. Эта команда разом включает PortFast, переводит порт в режим access \(аналогично switchport mode access\), 
и отключает протокол PAgP \(об этом протоколе подробнее в разделе агрегация каналов\).
{% endhint %}

## Виды STP

STP довольно старый протокол, он создавался для работы в одном LAN-сегменте. А что делать, если мы хотим внедрить его в нашей сети, которая имеет несколько VLANов?

Стандарт 802.1Q, о котором мы упоминали в статье о [коммутации,](https://linkmeup.gitbook.io/sdsm/2.-switching) определяет, каким образом вланы передаются внутри транка. Кроме того, он определяет один процесс STP для всех вланов. BPDU по транкам передаются нетегированными \(в native VLAN\). Этот вариант STP известен как **CST** \(Common Spanning Tree\). Наличие только одного процесса для всех вланов очень облегчает работу по настройке и разгружает процессор свича, но, с другой стороны, CST имеет недостатки: избыточные линки между свичами блокируются во всех вланах, что не всегда приемлемо и не дает возможности использовать их для балансировки нагрузки.

Cisco имеет свой взгляд на STP, и свою проприетарную реализацию протокола — **PVST** \(Per-VLAN Spanning Tree\) — которая предназначена для работы в сети с несколькими VLAN. В PVST для каждого влана существует свой процесс STP, что позволяет независимую и гибкую настройку под потребности каждого влана, но самое главное, позволяет использовать балансировку нагрузки за счет того, что конкретный физический линк может быть заблокирован в одном влане, но работать в другом. Минусом этой реализации является, конечно, проприетарность: для функционирования PVST требуется проприетарный же ISL транк между свичами.

Также существует вторая версия этой реализации — **PVST+**, которая позволяет наладить связь между свичами с CST и PVST, и работает как с ISL-транком, так и с 802.1q. PVST+ это протокол по умолчанию на коммутаторах Cisco.

