# Port security

Теперь расскажем вкратце, как обеспечить безопасность сети на втором уровне OSI. В этой части статьи теория и практическая конфигурация совмещены. Увы, Packet Tracer не умеет ничего из упомянутых в этом разделе команд, поэтому все без иллюстраций и проверок.

Для начала, следует упомянуть команду конфигурации интерфейса **switchport port-security**, включающую защиту на определенном порту свича. Затем, с помощью **switchport port-security maximum 1** мы можем ограничить количество mac-адресов, связанных с данным портом \(т.е., в нашем примере, на данном порту может работать только один mac-адрес\). Теперь указываем, какой именно адрес разрешен: его можно задать вручную **switchport port-security mac-address** _**адрес**_, или использовать волшебную команду **switchport port-security mac-address sticky**, закрепляющую за портом тот адрес, который в данный момент работает на порту. Далее, задаем поведение в случае нарушения правила **switchport port-security violation {shutdown \| restrict \| protect}**: порт либо отключается, и потом его нужно поднимать вручную \(shutdown\), либо отбрасывает пакеты с незарегистрированного мака и пишет об этом в консоль \(restrict\), либо просто отбрасывает пакеты \(protect\).

Помимо очевидной цели — ограничение числа устройств за портом — у этой команды есть другая, возможно, более важная: предотвращать атаки. Одна из возможных — истощение CAM-таблицы. С компьютера злодея рассылается огромное число кадров, возможно, широковещательных, с различными значениями в поле MAC-адрес отправителя. Первый же коммутатор на пути начинает их запоминать. Одну тысячу он запомнит, две, но память-то оперативная не резиновая, и среднее ограничение в 16000 записей будет довольно быстро достигнуто. При этом дальнейшее поведение коммутатора может быть различным. И самое опасное из них с точки зрения безопасности: коммутатор может начать все кадры, приходящие на него, рассылать, как широковещательные, потому что MAC-адрес получателя не известен \(или уже забыт\), а запомнить его уже просто некуда. В этом случае сетевая карта злодея будет получать все кадры, летающие в вашей сети.

## DHCP Snooping

Другая возможная атака нацелена на DHCP сервер. Как мы знаем, DHCP обеспечивает клиентские устройства всей нужной информацией для работы в сети: ip-адресом, маской подсети, адресом шюза по умолчанию, DNS-сервера и прочим. Атакующий может поднять собственный DHCP, который в ответ на запрос клиентского устройства будет отдавать в качестве шлюза по умолчанию \(а также, например, DNS-сервера\) адрес подконтрольной атакующему машины. Соответственно, весь трафик, направленный за пределы подсети обманутыми устройствами, будет доступен для изучения атакующему — типичная man-in-the-middle атака. Либо такой вариант: подлый мошенник генерируют кучу DHCP-запросов с поддельными MAC-адресами и DHCP-сервер на каждый такой запрос выдаёт IP-адрес до тех пор, пока не истощится пул.

Для того, чтобы защититься от подобного вида атак, используется фича под названием DHCP snooping. Идея совсем простая: указать свичу, на каком порту подключен настоящий DHCP-сервер, и разрешить DHCP-ответы только с этого порта, запретив для остальных. Включаем глобально командой **ip dhcp snooping**, потом говорим, в каких вланах должно работать **ip dhcp snooping vlan номер\(а\)**. Затем на конкретном порту говорим, что он может пренаправлять DHCP-ответы \(такой порт называется доверенным\): **ip dhcp snooping trust**.

## IP Source Guard

После включения DHCP Snooping’а, он начинает вести у себя базу соответствия MAC и IP-адресов устройств, которую обновляет и пополняет за счет прослушивания DHCP запросов и ответов. Эта база позволяет нам противостоять еще одному виду атак — подмене IP-адреса \(IP Spoofing\). При включенном IP Source Guard, каждый приходящий пакет может проверяться на:

* соответствие IP-адреса источника адресу, полученному из базы DHCP Snooping \(иными словами, айпишник закрепляется за портом свича\)
* соответствие MAC-адреса источника адресу, полученному из базы DHCP Snooping

Включается IP Source Guard командой **ip verify source** на нужном интерфейсе. В таком виде проверяется только привязка IP-адреса, чтобы добавить проверку MAC, используем **ip verify source port-security**. Само собой, для работы IP Source Guard требуется включенный DHCP snooping, а для контроля MAC-адресов должен быть включен port security.

## Dynamic ARP Inspection

Как мы уже знаем, для того, чтобы узнать MAC-адрес устройства по его IP-адресу, используется проткол ARP: посылается широковещательный запрос вида “у кого ip-адрес 172.16.1.15, ответьте 172.16.1.1”, устройство с айпишником 172.16.1.15 отвечает. Подобная схема уязвима для атаки, называемой ARP-poisoning aka ARP-spoofing: вместо настоящего хоста с адресом 172.16.1.15 отвечает хост злоумышленника, заставляя таким образом трафик, предназначенный для 172.16.1.15 следовать через него. Для предотвращения такого типа атак используется фича под названием Dynamic ARP Inspection. Схема работы похожа на схему DHCP-Snooping’а: порты делятся на доверенные и недоверенные, на недоверенных каждый ARP-ответ подвергаются анализу: сверяется информация, содержащаяся в этом пакете, с той, которой свич доверяет \(либо статически заданные соответствия MAC-IP, либо информация из базы DHCP Snooping\). Если не сходится- пакет отбрасывается и генерируется сообщение в syslog. Включаем в нужном влане \(вланах\): **ip arp inspection vlan номер\(а\)**. По умолчанию все порты недоверенные, для доверенных портов используем **ip arp inspection trust**.

