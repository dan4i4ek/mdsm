Название: Память сети. Как сохранить пакет




Эта статья едва ли для широкого круга читателей, но будет небезынтересна тем, кто хотел бы знать, сколько максимум пакет может полежать где-нибудь в сети, добираясь от точки А к точке Б, и как выбрать коммутатор так, чтобы через месяц от него не тянуло протухшими пакетами.
Для примера - на некоторых современных коммутаторах буферы по 4 гигабайта - спокойно можно четвёртый сезон Рика и Морти сохранить. Или вообще собрать кластер распределённого хранилища из коммутаторов. 

Это вторая статья, копающаяся в кишочках сетевых микросхем - в первой!!! я уже рассмотрел архитектуру сетевых устройств и чипов коммутации. А в этой взглянем на архитектуру памяти, выделение буферов и поднимем самый горячий вопрос современности - что лучше: большие и маленькие буферы.

<a href="https://fs.linkmeup.ru/images/articles/buffers/kdpv_buffers.jpg" target="_blank"><img src="https://fs.linkmeup.ru/images/articles/buffers/kdpv_buffers_s.jpg" width="800"></a>

Настоятельно рекомендую ознакомиться с <a href="https://linkmeup.ru/blog/365.html">15-м выпуском СДСМ</a> перед тем, как приступить к чтению.
<hr>

<h1>Содержание</h1>
<ul>
    <li><b><a href="#TERMINOLOGY">Терминология</a></b></li>

    <li><b><a href="#BUFERA">Память и буферы</a></b>
    <ul>
        <li><a href="#SFVSCT">Store-n-Forward vs Cut-Through</a></li>
        <li><a href="#CONGESTIONS">Перегрузки: причины и места</a>
        <ul>
            <li><i><a href="#CONGESTION_REASONS">Причины перегрузок</a></i></li>
            <li><i><a href="#CONGESTION_POINTS">Места образования перегрузок</a></i></li>
        </ul>
        </li>
        <li><a href="#BUFFER_ARCHITECTURE">Архитектура памяти</a>
        <ul>
            <li><i><a href="#CROSSBAR">Crossbar</a></i></li>
            <li><i><a href="#SHARED_BUFFER">Shared Buffers</a></i></li>
            <ul>
                <li><i><a href="#DEDICATED">Dedicated + Shared buffers</a></i></li>
                <li><i><a href="#HEADROOM">Headroom buffers</a></i></li>
                <li><i><a href="#ADMISSION_CONTROL">Admission Control</a></i></li>
                <li><i><a href="#ALPHA">Alpha</a></i></li>
            </ul>
            <li><i><a href="#OQ">Output queuing </a></i></li>
            <li><i><a href="#IQ">Input queuing </a></i></li>
            <li><i><a href="#CIOQ">Combined Input and Output queuing </a></i></li>
            <li><i><a href="#VOQ">Virtual Output Queueing</a></i></li>
        </ul>
        </li>
        <li><a href="#SHALLOW_VS_DIPPER">Shallow vs Deep buffers</a>
        <ul>
            <li><i><a href="#HYBRID_BUFFERING">Hybrid Buffering</a></i></li>
            <li><i><a href="#TRUE_EVIL">Большие буферы - это зло?</a></i></li>
        </ul>
        </li>
    </ul>
    </li>
    <li><b><a href="#LLLL">Lossless Low-Latency сети</a></b></li>
    <li><b><a href="#LINKS">Полезные ссылки</a></b></li>
</ul>

TL;DR
<cut />


<hr>
<a name="TERMINOLOGY"></a>
<h1>Терминология</h1>
Задача этого параграфа не объять все непонятные слова, употребляемые в статье, а лишь внести некую ясность в неразбериху русско-английских терминов.
<b>Чип коммутации</b>, <b>сетевой процессор</b>, <b>(Packet) Forwarding Engine</b>, <b>PFE</b> - микросхема, способная коммутировать пакет из входа в нужный выход с нужным набором заголовком.
<b>Lookup</b> или <b>лукап</b> или <b>поиск</b> - поиск адресата в таблицах (FIB, LFIB, ARP Adjacencies, IPv6 ND Table итд.)
<b>Pipeline</b> или <b>конвейер</b> - набор действий, которые происходят с пакетом по мере его продвижения от входа в чип до выхода из него.
<b>Single-chip</b>, <b>одночиповый</b> - устройство, внутри которого только один чип.
<b>Модульное сетевое устройство</b> - устройство, состоящее из шассии и отдельных карт, в него вставляющихся. В рамках статьи преполагаем, что каждая карта - это коммутатор с самостоятельным чипом коммутации, а друг с другом они связаны через фабрику коммутации.
<b>Fixed</b>, <b>фиксированный</b>, <b>pizza-box</b> - немодульный коммутатор. Обычно внутри него нет фабрик коммутации. Часто эти термины используются как синоним Single-chip, хотя это не совсем верно - внутри может стоять два (back-to-back) чипа или даже больше.
<b>Сериализация/Десериализация</b> - процесс перевода данных из параллельного низкоскоростного интерфейса (МГц) в
последовательный высокоскоростной (ГГц) и наоборот. Например, из чипа в интерфейс или из чипа в фабрику.
<b>Память</b> - физическая микросхема для хранения.
<b>Буфер</b> - некий участок памяти, выделенный для хранения пакетов. <i>Здесь и далее в производных словах, таких как "буферов", ударение на "У"</i>.
<b>Очередь</b> - абстракция над буфером, позволяющая <b>виртуально</b> выстраивать пакеты в упорядоченную очередь. Фактически в памяти они, конечно, хранятся "как попало".
<b>OCB</b> - On-Chip Buffer. Память, встроенная в чип.
<b>MMU</b> - Memory Management Unit - блок управления физической памятью.
<b>TM</b> - Traffic Manager - блок, реализующий функции QoS, использует MMU для доступа к памяти.
<hr>

<a name="SFVSCT"></a>
<h2>Назначение буферов</h2>

Итак, в прошлый раз !!! мы проследили судьбу пакета внутри чипа - какие именно микросхема предпринимает шаги, чтобы передать сигнал со входного интерфейса в выходной. Этот набор шагов называется конвейером или Pipeline'ом.

Ключевая часть процесса - это то, что чип отрезает от пакета значимую часть - а именно первые сколько-то байтов, содержащих управляющие заголовки. Блок Parser эти заголовки разбирает, а блок Match-Action делает лукап по таблицам и определяет, что с пакетом нужно сделать (интерфейс, инкапсуляции, шейпинг, полисинг, ремаркировка итд.)

Все эти действия происходят только с заголовкамии пакетов.
А где же прохлаждаются их тела всё это время?

В сетевых чипсетах есть встроенная память (<b>on chip-OCB</b>) как раз для хранения тел. Её размер в силу физических ограничений очень мал (до 100Мб), но для большинства задач - это разумный компромисс.
Лишь в редких сценариях этого не хватает и добавляется объёмная внешняя память - <b>off-chip</b>.
<blockquote>
    Вообще про компромиссы мало-много памяти поговорим <a href="#SHALLOW_VS_DIPPER">отдельно</a>.
</blockquote>

<img src="https://fs.linkmeup.ru/images/articles/buffers/buffer_memory.png" width="500">

Таким образом на входе в чип парсер отделяет заголовки от тел, первые отдаёт на анализ в блок Match-Action, вторые - складывает в буфер.
На выходе новые заголовки пришивают к извлечённым обратно телам и отправляют на выход.

Будучи неоднократно обвинённым при рецензировании этой статьи, чувстую необходимость ещё раз повторить это: внутри чипа коммутации заголовки отделяются от тела пакета. В то время, как изначальные заголовки анализируются, помогают сделать лукап, уничтожаются, формируются новые, тело находится в одном месте физической памяти, не перемещаясь. Даже в тот момент, когда Traffic Manager выстраивает пакеты в очередь согласно их приоритетам, производит их диспетчеризацию и Congestion Avoidance, фактически он работает со внутенними временными заголовками, не двигая пакеты по памяти. 


Управляет доступом к физической памяти <b>MMU - Memory Management Unit</b>. Он довольно похож на MMU в компьютерах (по сути является <a href="https://en.wikipedia.org/wiki/Memory_management_unit">им</a>). Программа обращается к указателю, чтобы извлечь данные из памяти, MMU транслирует это в реальный адрес ячейки и возвращает данные. 

MMU занимается размещением пакетов в буферах, их извлечением или отбрасыванием. Он же контролирует разделение памяти на области (dedicated, shared, headroom, voq) и их загрузку.

За более верхнеуровневое управление очередями и перегрузками отвечает блок <b>TM - Traffic Manager</b>.

Есть два подхода к размещению тел в буферах: <b>Store-and-Forward</b> и <b>Cut-Through</b>.
<hr>

<a name="SFVSCT"></a>
<h2>Store-and-Forward vs Cut-Through</h2>
<b>SF - Store and Forward</b> предполагает, что чип сначала получает полностью пакет, сохраняет в буфере, а уже потом занимается вивисекцией.
После анализа заголовков пакет помещается в правильную выходную очередь.
Исторически это первый метод коммутации. Его преимущество в том, что он может, получив пакет целиком, проверить контрольную сумму и выбросить побитые.

<b>CT - Cut-Through</b>, напротив, сразу после получения первых нескольких десятков байтов пакета, позволяющих принять решение о его судьбе, отправляет его в выходную очередь, не дожидаясь его полной доставки.
Это позволяет сэкономить до нескольких микросекунд на обработке пакета внутри коробки, ценою, однако, отсутствия проверки целостности - ведь FCS-то в конце. Эта задача перекладывается на протоколы более высокого уровня (или на следующий хоп).

Такой режим используется для приложений, требующих ультра-коротких задержек.

<blockquote>
    К слову на сегодняшний день для коммутаторов 2-го уровня время обработки в пределах устройства порядка 200нс, 3-го - 250нс.

    Для коммутаторов 1-го уровня (фактически патч-панель) это время - около 5 нс.
</blockquote>

Многие производители сегодня по умолчанию устанавливают режим Cut-Through, поскольку ошибки на Ethernet сегодня явление сравнительно нечастое, а приложение обычно само может обнаружить проблему и запросить переотправку (или не запрашивать, кстати).

<b>Дальнейшее чтение</b>:
Весьма глубокий подкоп под режимы коммутации от циски: <a href="https://www.cisco.com/c/en/us/products/collateral/switches/nexus-5020-switch/white_paper_c11-465436.html">Cisco Nexus 5000 Series Switches</a>
<hr>

<a name="CONGESTIONS"></a>
<h2>Перегрузки: причины и места</h2>
Буфер нужен на сетевом устройстве не только для того, чтобы похранить тело пакета, пока его заголовки перевариваются в кишках чипа.
Как минимум нужно сгладить поток пакетов до скорости выходного интерфейса. Грубо говоря, пока один пакет сериализуется для передачи в интерфейс, второму нужно где-то подождать.
Для этой задачи обычно хватит совсем небольшой FIFO очереди. 
Другая важнейшая сетевая задача - перегрузки (congestion). Если в один интерфейс одновременно сваливается много пакетов, их тоже нужно сохранить.

Причём перегрузки - это наша повседневная легитимная реальность, а не что-то крайне редкое, что нужно перетерпеть и станет попроще.
Во времена коммутации каналов такой проблемы не стояло - для любой общающейся пары всегда было зарезервировано строго необходимое количество ресурсов.
Сегодня совершенно законно на порт может прийти больше трафика, чем тот готов сиюминутно пропустить.
<hr>

<a name="CONGESTION_REASONS"></a>
<h3>Причины перегрузок</h3>
Самая простая - из высокоскоростного интерфейса трафик должен слиться в более низкоскоростной - из <b>10G в 1</b>, например.
Другая причина, очень распространённая в сетях крупных ДЦ, особенно в тех, где развёрнуты кластеры Map-Reduce - это <b>Incast</b>. Это ситуация, в которой одна машина отправляет запрос на десятки/сотни/тысячи, а те все разом начинают отвечать, и пакеты стопорятся на узком интерфейсе в сторону машины-инициатора.
Более общий случай - трафик с нескольких входящих портов должен влиться в один исходящий - <b>Backpressure</b>.
Прочие типы всплесков трафика, которые ещё называют бёрстовыми или просто бёрстами (<b>Bursts</b>).


Поэтому однозначно нужно побольше памяти для буферизации. Но фактически это место, где пакеты обрастают задержкой.
Так на заре 1G буферизация вызывала массу головной боли у трейдеров, чьи приложения получали свой бесценный трафик с задержкой и джиттером.

И поэтому тут уже недостаточно везде FIFO. Это задача, во благо которой трудится <a href="https://linkmeup.ru/blog/365.html">QoS</a>.

Если случилась конгестия, то нужно иметь возможность требовательный к задержкам трафик, пропустить первым, чувствительный к потерям - не дропнуть, а наименее ценным пожертвовать. 
Ещё нужно уметь пополисить и пошейпить. 

Но в каком месте располагать эту память и где реализовывать QoS?
<hr>

<a name="CONGESTION_POINTS"></a>
<h3>Места возникновения перегрузок</h3>
Их по большому счёту 4: 
<ol>
    <li><b>на входном чипе</b> - если со стороны интерфейсов на него поступает больше, чем он способен обработать.</li>
    <li><b>на фабрике коммутации</b> (если коробка модульная) - если линейные карты пытаются отправить на фабрику больше, чем она способна обработать.</li>
    <li><b>на выходной линейной карте</b>, если фабрика пытается передать на линейную карту больше, чем её чип способен обработать</li>
    <li><b>на выходном интерфейсе</b> - если чип шлёт в интерфейс больше, чем тот способен сериализовать.</li>
</ol>

<img src="https://fs.linkmeup.ru/images/articles/buffers/congestion_points.svg" width="600">

Но никто не хочет бороться с перегрузками в четырёх местах.
Поэтому обычно
А) Чип делают такой производительности, чтобы он смог обработать весь трафик, даже если тот начал одновременно поступать со всех портов на этой линейной карте. Поэтому для устройства со 128 портами 100Гб/с используется чип с производительностью 12,8Тб/с.
Очевидно бывают и исключения. Тогда или имеем непредсказуемые потери, или (чаще) невозможность использовать часть портов.
Б) Фабрику так же делают без переподписки, чтобы она могла провернуть весь трафик, который пытаются в неё передать все линейные карты, даже если они делают это одновременно на полной скорости. Таким образом не нужно буферизировать трафик и перед отправкой на фабрику. 
В) Управление перегрузками на выходном чипе и выходном интерфейсе сводят в одно место.

<blockquote>
    На самом деле фабрика без передподиски (или неблокируемая) - это та ещё спекуляция, к которой нередко прибегают маркетологи. 
    Для некоторых сценариев, например, <a href="#CIOQ">CIOQ</a> даже со speedup фабрики в пару раз от необходимого есть строгие результаты, показывающие, при каких условиях она будет неблокируемой.
    Можно почитать у достопочтенных выпускников MIT и Стэнфорда: <a href="http://yuba.stanford.edu/~nickm/papers/CSL-TR-97-738.pdf" target="_blank">On the speedup required for combined input and output queued switching</a>.
</blockquote>

<hr>

<a name="BUFFER_ARCHITECTURE"></a>
<h>Архитектура буферов</h1>
И вот тут на сцену выходит TM - Traffic Manager, который реализует функции QoS (и некоторые другие).
Он может быть частью чипа коммутации, а может быть отдельной микросхемой - для нас сейчас важно то, что он заправляет буферами.

Буфер - это с некоторыми оговорками обычная память, используемая в компьютерах. В ней в определённой ячейке хранится пакет, который чип может извлечь, обратившись по адресу. 

Любой сетевой ASIC или NP обладает некоторым объёмом встроенной (on-chip) памяти (порядка десятков МБ).
Так называемые Deep-Buffer свитчи имеют ещё внешнюю (off-chip) память, исчисляемую уже гигабайтами.
И той и другой управляет модуль чипа - MMU.

В целом для нас пока местонахождение не имеет значения - взглянем на это <a href="#SHALLOW_VS_DIPPER">попозже</a>. Важно то, как имеющейся памятью чип распоряжается, а именно, где и какие очереди он создаёт и какие <a href="https://en.wikipedia.org/wiki/Active_queue_management" target="_blank">AQM</a> использует. 

И тут практикуют:

<ul>
    <li><a href="#CROSSBAR">Crossbar</a></li>
    <li><a href="#SHARED_BUFFER">Shared Buffer</a></li>
    <li><a href="#OQ">Output Queuing</a></li>
    <li><a href="#IQ">Input Queueing</a></li>
    <li><a href="#CIOQ">Combined Input and Output Queueing</a></li>
    <li><a href="#VOQ">Virtual Output Queueing</a></li>
</ul>
<hr>

<a name="CROSSBAR"></a>
<h2>Crossbar</h2>
Идея в том, чтобы для каждой пары (входной интерфейс - выходной интерфейс) выделить аппаратный буфер.
<img src="https://fs.linkmeup.ru/images/articles/buffers/crossbar.png" width="500">

Это, скорее, умозрительный эксперимент, потому что в плане сложности, стоимости реализации и эффективности это проигрышный вариант.
<hr>

<a name="SHARED_BUFFER"></a>
<h2>Shared Buffer</h2>
По числу существующих в мире коробок этот вариант, однозначно, на первом месте. 

<img src="https://fs.linkmeup.ru/images/articles/buffers/shared_buffer.png" width="500">

Используется Shared Buffer на немодульных устройствах без фабрики коммутации, в которых установлен один чип (обычно, но может быть больше).

Аппаратно - это память (обычно SRAM), встроенная прямо в чип - она так и называется <b>on-chip</b> (OCB)    . Много туда не засунешь, поэтому объём до 100 МБ.
Зачастую это единственная память, которая в одночиповых устройствах используется для буферизации.
Пусть, однако, эта кажущаяся простота не вводит вас в заблуждение - для того, чтобы в десятки мегабайтов поместить трафик сотни портов 100Гб/с, да ещё и обеспечить отсутствие потерь, за ними должны скрываться годы разработок и нетривиальная архитектура.
А так оно и есть - я чуть ниже неглубоко вас окуну.

Итак, есть соблазн эту память взять и просто равномерно разделить между всеми портами. Такой статический дизайн имеет право на жизнь, но сводит на нет возможность динамически абсорбировать всплески трафика.

Гораздо более привлекательным выглядит следующий вариант:

<a name="DEDICATED"></a>
<h3>Dedicated + Shared</h3>
Из доступной памяти каждому порту выделяется определённая небольшая часть - это <b>Dedicated Buffer</b>. За каждым портом кусочек памяти законодательно закреплён и не может быть использован другими портами. То есть при любых обстоятельствах у порта будет свой защищённый кусочек. Минимальный размер Dedicated Buffer где-то настраивается, где-то нет. Но лучше без основательного понимания в дефолты не лезть.
Доля каждого порта в абсолютных цифрах очень маленькая - порядка единиц кБ.
Гарантируемый минимум выделяется для хранения как входящих пакетов, так и выходящих.

Остальная часть памяти как раз общая - <b>Shared Buffer</b> - может быть использована любым портом по мере необходимости. Из неё динамически выделяются куски для тех интерфейсов, которые испытывают перегрузку. 
Например, если чип пытается на один из интерфейсов передать больше трафика, чем тот способен отправлять в единицу времени, то эти пакеты сначала заполняют выделенный для этого порта буфер, а когда он заканчивается, автоматически начинают складываться в динамически выделенный буфер из общей памяти. Как только все пакеты обработаны, память освобождается.
Под общий буфер может быть отдано 100% той памяти, что осталась после вычитания из неё выделенных для портов кусочков (Dedicated). Но она так же может быть перераспределена - за счёт общего буфера можно увеличить выделенные. Так, если выделить 80% под Shared, то оставшиеся 20% равномерно распределятся по Dedicated.

Наличие Shared Buffer'а решает огромную проблему, позволяя сглаживать всплески трафика, когда перегрузку испытывает один или несколько интерфейсов.

Однако вместе с тем за общую память начинаются соревноваться разные порты одновременно. И серьёзная перегрузка на одном порту может вызвать потери на другом, которому нужно было всего лишь несколько килобайтов общей памяти, чтобы не дропнуть пакет.
Одним из способов облегчить эту ситуацию является увеличение выделенных буферов за счёт уменьшения общего.
Но это всегда зона компромиссных решений - сокращая размер общей памяти, мы уменьшаем и объёмы всплесков, которые чип может сгладить.
Кроме того <a href="#LLLL">Lossless трафик</a> требует к себе ещё более щепетильного отношения.

Поэтому зачастую, помимо Dedicated и Shared буферов, резервируют ещё <b>Headroom buffers</b>.

<a name="HEADROOM"></a>
<h3>Headroom buffers</h3>
Это последний способ сохранить пакеты, когда даже общий буфер уже забит. Естественно, он тоже отрезается от общей памяти, поэтому на первый взгляд выглядит не очень логичным откусить от общей памяти кусок, назвать его по-другому и сказать, мол, мы всё оптимизировали.
На самом деле Headroom буферы решают довольно специфическую задачу - помочь lossless приложениям с <b>PFC</b> - <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/cos-qfx-series-congestion-notification-understanding.html#jd0e554" target="_blank">Priority-based Flow Control</a>.

PFC - это механизм Ethernet Pause, который умеет притормаживать не всю отправку, а только по конкретным приоритетам Ethernet CoS.
Например, два приложения на отправителе: RoCE и репликация БД. Первое - чувствительная к задержкам и потерям вещь, второе - массивные данные.
Коммутатор, заметив заполнение общего буфера, отправляет Pause для более низкого приоритета, тем самым притормаживая репликацию, но не RoCE.
Задача буфера Headroom здесь в том, чтобы сохранить те пакеты приоритетной очереди, что сейчас в кабеле, пока Pause летит к отправителю с просьбой притормозить.
То есть пакеты репликации начнут дропаться, когда заполнится общий буфер, а пакеты RoCE будут складываться в Headroom. 
<blockquote>
    Помимо lossless headroom бывает и headroom для обычного трафика, чтобы помочь сохранить более приоритетный. Но это на домашнее задание.
</blockquote>

<img src="https://fs.linkmeup.ru/images/articles/buffers/buffer_types.svg" width="800">

При наступлении перегрузки буферы будут задействованы в следующем порядке.
Для входящего best-effort трафика:
<ol>
    <li>Dedicated buffers</li>
    <li>Shared buffers</li>
</ol>

Для входящего lossless трафика:
<ol>
    <li>Dedicated buffers</li>
    <li>Shared buffers</li>
    <li>Lossless headroom buffers</li>
</ol>

Для всего исходящего трафика:
<ol>
    <li>Dedicated buffers</li>
    <li>Shared buffers</li>
</ol>

Разумеется, описанное выше лишь частный пример, и от вендора к вендору ситуация может различаться (разительно).

Например бродкомовские чипы (как минимум Trident и Tomahawk) имеют внутреннее разделение памяти по группам портов. Общая память делится на порт-группы по 4-8 портов, которые имеют свой собственный кусочек общего буфера. Порты из одной группы, соответственно буферизируют пакеты только в своём кусочке памяти и не могут занимать другие. Это тоже один из способов снизить влияние перегруженных портов друг на друга. Такой подход иногда называют <b>Segregated Buffer</b>.

<a name="ADMISSION_CONTROL"></a>
<h3>Admission Control</h3>
Admission Control - входной контроль - механизм, который следит за тем, можно ли пакет записывать в буфер. Он не является специфичным для Shared-буферов, просто в рамках статьи - это лучшее место, чтобы о нём рассказать.

Формально Admission Control делится на Ingress и Egress.
Задача <b>Ingress Admission Control</b> - во-первых, вообще убедиться, что в буфере есть место, а, во-вторых, обеспечить справедливое использование памяти.
Это означает, что у каждого порта и очереди всегда должен быть гарантированный минимальный буфер. А ещё несколько входных портов не оккупируют целиком весь буфер, записывая в него всё новые и новые пакеты.

Задача <b>Egress Admission Control</b> - помочь чипу абсорбировать всплески, не допустив того, чтобы один или несколько выходных портов забили целиком весь буфер, получая всё новые и новые пакеты с кучи входных портов.

В случае Shared Buffer оба механизма срабатывают в момент первичного помещения пакета в буфер. То есть никакой двойной буферизации и проверки не происходит. 

Как именно понять, сколько буфера занято конкретным портом/очередью и главное, сколько ещё можно ему выдать?
Это может быть статический порог, одинаковый для всех портов, а может быть и динамически меняющийся, регулируемый параметром <b>Alpha</b>.

<a name="ALPHA"></a>
<h3>Alpha</h3>
Итак, почти во всех современных чипах память распределяется динамически на основе информации о том, сколько общей памяти вообще свободно и сколько ещё можно выделить для данного порта/очереди.

На самом деле минимальной единицей аккаунтинга является не порт/очередь, а регион (в терминологии Мелланокс). Регион - это кортеж: <i>(входной порт, Priority Group на входном порту, выходной порт, Traffic Class на выходном порту)</i>.

Каждому региону назначается динамический порог, сколько памяти он может под себя подмять. При его превышении, очевидно, пакеты начинают дропаться, чтобы не влиять на другие регионы.
Этот порог вычисляется по формуле, множителями которой являются объём свободной на данный момент памяти и параметр <b>alpha</b>, специфичный для региона и настраиваемый:
<code>Threshold [Bytes] = alpha * free_buffer [Bytes]</code>

Его значение варьируется от 1/128 до примерно 8 с шагом х2. Чем больше эта цифра, тем больший объём свободной памяти доступен региону.
Например, если на коммутаторе 32 региона, то: 
при alpha=1/64 каждому региону будет доступна 1/64 часть свободной памяти, и даже при максимальной утилизации они все смогут использовать только половину буфера.
при alpha=1/32 вся память равномерно распределится между регионами, ни один из них не сможет влиять на другие, а при полной утилизации 100% памяти будет занято.
при alpha=1/16 каждый регион может претендовать на больший объём памяти. И если все регионы разом начнут потреблять место, то им всем не хватит, потому что памяти потребовалось бы 200%. То есть это своего рода переподписка, позволяющая сглаживать всплески.
<i>Предполагаем тут, что значение alpha одинаково для всех регионов, хотя оно может быть настроено отдельно для каждого.</i>

При получении каждого пакета, механизм Admission Control вычисляет актуальный порог для региона, которому принадлежит пакет. Если порог меньше размера пакета, тот отбрасывается.
Если же больше, то он помещается в буфер и уже не будет отброшен никогда, даже если регион исчерпал все лимиты. Объём свободной памяти уменьшается на размер пакета.
Это происходит для каждого приходящего на чип пакета.
<hr>

Написанное выше об Admission Control и Alpha может быть справедливо не только для Shared Buffers, но и для других архитектур, например, VoQ.

<b>Дальнейшее чтиво:</b>
<ul>
    <li>Если в жизни не хватает страданий: <a href="https://montazeri.iut.ac.ir/sites/montazeri.iut.ac.ir/files/file_pubwdet/32083_0.pdf" target="_blank">Design and Implementation of a Shared Memory Switch Fabric</a></li>
    <li><a href="https://community.mellanox.com/s/article/understanding-the-alpha-parameter-in-the-buffer-configuration-of-mellanox-spectrum-switches" target="_blank">Understanding the Alpha Parameter in the Buffer Configuration of Mellanox Spectrum Switches</a></li>
    <li>Programming Guide'ы коммерческих микросхем (NDA кровью, помним, да?).</li>
</ul>
<hr>

Crossbar и Shared Buffer - это архитектуры, которые могут использоваться для устройств фиксированной конфигурации, но не подходят для модульных.
Взглянем же теперь на них.

Дело в том, что они состоят из нескольких линейных карт, каждая из которых несёт как минимум один самостоятельный чип коммутации.
И этот чип, будь то ASIC, NP или даже CPU не может в своей внутренней памяти динамически выделять буферы для тысяч очередей выходных интерфейсов - кишка тонка. 

<img src="https://fs.linkmeup.ru/images/articles/buffers/modular_chassis.svg" width="800">

Далее поговорим про архитектуры памяти для модульных шасси:
<ul>
    <li><a href="#OQ">Output Queueing</a></li>
    <li><a href="#IQ">Input Queueing</a></li>
    <li><a href="#CIOQ">Combined Input and Output Queueing</a></li>
    <li><a href="#VOQ">Virtual Output Queueing</a></li>
</ul>

<a name="OQ"></a>
<h3>Output Queueing</h3>
Наиболее логичным кажется буферизировать пакеты как можно ближе к месту возможного затора - около выходных интерфейсов.
Кому как не выходному чипу знать о здоровье своих подопечных интерфейсов, обслуживать по несколько QoS очередей для каждого и бороться с перегрузками?

<img src="https://fs.linkmeup.ru/images/articles/buffers/oq.png" width="500">

И это правда так.
Но есть одна фундаментальная проблема - в случае перегрузок пакеты будут приходить на Egress PFE, чтобы умирать. Они проделают весь огромный путь от входного интерфейса через фабрику коммутации до выходного буфера через фабрику для того, чтобы узнать, что мест нет и быть печально дропнутыми.
Это бессмысленная и бесполезная утилизация полосы пропускания фабрики.

<img src="https://fs.linkmeup.ru/images/articles/buffers/drop.svg" width="800">

И вот уже вырисовывается следующая логичная мысль - выбросить пакет нужно как можно раньше.
Как было бы здорово, если бы мы могли это сделать на входной плате.
<hr>

<a name="IQ"></a>
<h3>Input Queuing</h3>
Более удачным вариантом оказывается буферизировать пакеты на входной плате после лукапа, когда уже становится понятно, куда пакет слать. Если выходной интерфейс заведомо занят, то и смысла гнать камикадзе на фабрику нет.

<img src="https://fs.linkmeup.ru/images/articles/buffers/iq.png" width="500">

Постойте! Как же входной чип узнает, что выходной интерфейс не занят? 

С точки зрения Data Plane никакой обратной связи, от выходного чипа входному, очевидно, нет. Распространение между ними информации, необходимой для лукапа (некстхопы, интерфейсы, заголовки) производится средствами медленного Control Plane - тоже не подойдёт. 
Так вот для сигнализации такой информации между линейными платами появляется арбитр. У разных вендоров он может быть реализован по-разному, но суть его в следующем - входной чип регулярно запрашивает у выходного разрешение на отправку нового блока данных. И пока он его не получит - держит пакеты в своём буфере, не отправляя их в фабрику.
Соответственно выходной чип, получив такой запрос, смотрит на утилизацию выходного интерфейса и решает, готов ли он принять пакет. Если да - отправляет разрешение (<b>Grant</b>).
Это на первый взгляд контринтуитивное поведение - каковы же накладные расходы на такой арбитраж, насколько это увеличивает задержки, если на отправку пакета данных нужно дождаться RTT в пределах коробки - пока запрос улетит на выходной чип, пока тот обработает, пока ответ вернётся назад.
Тут для меня начинается область магического искусства, но вендоры эту революцию успели совершить и есть масса платформ, на которых арбитр прекрасно со своей задачей справляется. 
Хотя обычно он применяется не для Input Queueing в описанном виде.
Дело в том, что эффективность Input Queueing не очень высокая - очень часто придётся ждать, пока интерфейс освободится. Эх, прям вспоминается старый добрый Ethernet CSMA/CD.
<hr>

<a name="CIOQ"></a>
<h3>Combined Input and Output Queueing</h3>
Гораздо выгоднее в этом плане разрешить буферизацию и на выходе.
Тогда арбитр будет проверять не занятость интерфейса, а степень заполненности выходного буфера - вероятность, что в нём есть место, гораздо выше.

<img src="https://fs.linkmeup.ru/images/articles/buffers/cioq.png" width="700">

Но такие вещи не даются даром. Очевидно, это и увеличенная цена из-за необходимости реализовывать дважды буферизацию, и увеличенные задержки - даже в отсутствие заторов этот процесс не бесплатный по времени.

Кроме того, для обеспечения QoS придётся хоть какой-то минимум его функций реализовывать в двух местах, что опять же скажется на цене продукта

Но у CIOQ (как и у IQ) есть фундаментальный недостаток, заставивший в своё время немало поломать голову лучшим умам - <b>Head of Line Blocking</b>. 

Представьте себе ситуацию: однополосная дорога, перекрёсток, машине нужно повернуть налево, сквозь встречный поток. Она останавливается, и ждёт, когда появится окно для поворота. А за ней стоит 17 машин, которым нужно проехать прямо. Им не мешает встречный поток, но им мешает машина, которая хочет повернуть налево.

<img src="https://fs.linkmeup.ru/images/articles/buffers/hlob.png" width="500">
<i><a href="https://www.cisco.com/c/dam/global/hr_hr/assets/ciscoconnect/2013/pdfs/Anatomy_of_Core_Network_Elements_Josef_Ungerman.pdf" target="_blank">Источник</a>.</i>

Этот избитый пример иллюстрирует ситуацию HoLB. Входной буфер - один на всех. И если всего лишь один выходной интерфейс начинает испытывать затор, он блокирует полностью очередь отправки на выходном чипе, поскольку один пакет в начале этой очереди не получает разрешение на отправку на фабрику. 

Трагическая история, как в реальной жизни, так и на сетевом оборудовании.
<hr>

<a name="VOQ"></a>
<h3>Virtual Output Queueing</h3>
Как можно исправить эту дорожную ситуацию? Например, сделав три полосы - одна налево, другая прямо, третья направо.

Ровно то же самое сделали разработчики сетевого оборудования.
Они взяли входной буфер побольше и подробили его на множество очередей.
Для каждого выходного интерфейса они создали по 8 очередей на каждом чипе коммутации. То есть перенесли все задачи по обеспечению QoS на входной чип. На выходном же при этом остаётся самая базовая FIFO очередь, в которой никогда не будет заторов, потому что их контроль взял себя входной чип.

<img src="https://fs.linkmeup.ru/images/articles/buffers/voq.png" width="500">

Если взять грубо коробку со 100 интерфейсами, то на каждой плате в буферах нужно будет выделить 800 очередей. 
Если в коробке всего 10 линейных карт, то общее число очередей на ней будет 100*8*10 = 8000.

Однако V в VOQ означает виртуальный, не потому, что они как бы выходные, но на самом деле находятся на входных платах, а потому что Output Queue для каждого выходного интерфейса распределён между всеми линейными картами. То есть сумма 10и физических очередей для одного интерфейса на 10 чипах составляет 1 виртуальную. 
Собственно из-за распределённого характера этой виртуальной очереди от арбитра и здесь избавиться не получится - разным входным чипам всё же нужно знать, состояние выходной очереди. Поэтому даже несмотря на то, что выходная очередь - это FIFO, выходной чип всё ещё должен давать добро на отправку трафика. 

Кстати, что касается трафика, который должен вернуться в интерфейс той же карты, на которую он пришёл изначально, то здесь никаких исключений - он томится в VOQ, пока чип не даст добро переложить его в выходную очередь. 
Причём зачастую такому трафику придётся даже выйти на фабрику, потому что Ingress и Egress части полностью разделены.
Поэтому перед лицом перегрузок все равны.

На сегодняшний день подавляющее большинство модульных сетевых устройств используют архитектуру VOQ.

<b>Дальнейшее чтиво: </b>
<ul>
    <li>
        <a href="https://people.ucsc.edu/~warner/Bufs/Buffering-WP_August_2017.pdf" target="_blank">An Update on Router Buffering</a>
    </li>
    <li>
        <a href="https://forums.juniper.net/t5/forums/recentpostspage/post-type/message/category-id/Blogs/user-id/101479" target="_blank">What is VOQ and why you should care?</a>
    </li>
    <li>
        <a href="https://archive.nanog.org/sites/default/files/wednesday_tutorial_szarecki_packet-buffering.pdf" target="_blank">Strategies of packet buffering inside Routers</a>
    </li>
    <li>
        <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/cos-qfx-series-voq-understanding.html" target="_blank">Understanding CoS Virtual Output Queues (VOQs) on QFX10000 Switches</a>
    </li>
    <li>
        <a href="https://books.google.ru/books?id=kzstoFdvZ2sC&pg=PR8&lpg=PR8&dq=shared+memory+vs+voq&source=bl&ots=mTy-1ifsRK&sig=ACfU3U0DHx37_i_oDKvDJTEh72g6pSW-Ng&hl=ru&sa=X&ved=2ahUKEwjnx9el0LPnAhWHAhAIHUF6CeIQ6AEwCHoECAgQAQ#v=onepage&q=shared%20memory%20vs%20voq&f=false" target="_blank">High Performance Switches and Routers</a> - если у вас есть лишних 14 к₽.
    </li>
</ul>


<hr>

<a name="SHALLOW_VS_DIPPER"></a>
<h1>Shallow vs Deep Buffers</h1>
Буферы - это то место, где пакеты можно похранить, вкачав в них смертельную порцию задержки.
Как сказали в <a href="https://www.youtube.com/watch?v=Ti3t9OAZL3g">видео Packet Pushers</a> - буферы - это религия. Хотя, скорее всего, неортодоксальная, а возможно даже секта.

Чуть позже мы поговорим о том, что такое хорошо, а что такое плохо. А пока посмотрим на реализации. 

<b>Shallow</b> - неглубокие - это буферы размером до 100МБ. Обычно это встроенная в кристалл <b>on-chip</b> память - <b>OCB</b> - On-Chip Buffer.
<b>Deep</b> - счёт уже идёт на гигабайты. Обычно <b>off-chip</b> и подключается к чипу по отдельной шине.
И нет ничего посередине.

За последние лет десять производительность чипов выросла на порядки, трафика они теперь перемалывают терабиты в секунду вместо единиц гигабит. А размер памяти не то что не поспевает за этим ростом, он фактически почти стоит на месте. 
Давайте грубо прикинем: если для гигабитного порта буфер размером 16 мегабайт мог абсорбировать всплеск трафика длительностью примерно 100 мс, то для 100Гб/с - всего лишь 1мс. И это только один порт, фактически же плотность портов тоже растёт и максимальная комплектация для одночипового устройства сегодня - 64 порта 400Гб/с - или 25,6 Тб/с полосы пропускания. 
Используя только 64 МБ буфер, такой чип сможет хранить трафик 0.000005 c или 5 мкс.

Такие буферы порой даже называют <a href="https://conferences.sigcomm.org/events/apnet2017/papers/bcc-bai.pdf">Extremely shallow buffers</a>. 

Их воистину миниатюрный объём обусловлен в первую очередь тем, что они в прямом смысле встроены в чип. Такая память является составной частью микросхемы, и каждый дополнительный мегабайт, разумеется, будет обходиться в лишнюю тысячу долларов, больший размер и тепловыделение. Для справки Broadcom Trident 4 содержит 21 миллиард транзисторов, изготовленных по 7нм техпроцессу на нескольких квадратных сантиметрах.
Логично вытекающим следствием является скорость работы с этой памятью - она должна соответствовать производительности чипа.


<img src="https://fs.linkmeup.ru/images/articles/buffers/trident4_memory.png" width="400">


Очевидно, что не для всех задач такие маленькие буферы подходят. В частности модульные коробки с VOQ явно не могут позволить себе дробить 64 Мб на несколько тысяч очередей (на самом деле <a href="#HYBRID_BUFFERING">могут</a>).

Поэтому рынок предлагает решения с большой внешней памятью (Deep Buffers), размер которой начинается от 1ГБ (обычно от 4ГБ).
Согласно <a href="https://people.ucsc.edu/~warner/buffer.html" target="_blank">этой таблице</a> существуют коммутаторы (Arista 7280QR-C48) с фантастическими 32-хгигабайтовыми буферами - это уже все сезоны Рика и Морти в неплохом качестве. Но это уже история про VOQ - всё-таки это память не одного чипа. На моём первом ПК такого объёма был жёсткий диск. 

Как такая память реализована зависит уже от чипа и коробки.
Например, Broadcom <b>Jericho+</b> сгружает пакеты во внешнюю память в размере 4ГБ. Это обычная широко известная <b>GDDR5</b>, использующаяся в видеокартах.



<img src="https://fs.linkmeup.ru/images/articles/buffers/jericho_deep_beffers.png" width="500">
<i><a href="https://xrdocs.io/ncs5500/blogs/2018-05-07-ncs-5500-buffering-architecture/" target="_blank">Источник</a></i>.


<b>Jericho2</b> несёт на борту новейшую память <b>HBM2</b> - High Bandwidth Memory - размером 8ГБ.


<img src="https://fs.linkmeup.ru/images/articles/buffers/jericho2_deep_beffers.png" width="400">
<i><a href="https://www.broadcom.com/products/ethernet-connectivity/switching/stratadnx/bcm88690" target="_blank">Источник</a></i>.


<img src="https://fs.linkmeup.ru/images/articles/buffers/chipset_die.png" width="800">

А вот и фото Jericho2:
<img src="https://fs.linkmeup.ru/images/articles/buffers/hbm_photo.png" width="400">
<i><a href="https://people.ucsc.edu/~warner/Bufs/CSG-DNX-Switching-J2%20Feb%2016%202018.pdf">Источник</a>.</i>


Juniper QFX10000 использует чип <b>Q5</b> собственного производства с внешней памятью - <b>HMC</b> - Hybrid Memory Cube - в размере 4ГБ. HMC - это коммерческая память производства Micron, от которой ныне отказались в пользу HBM и GDDR6.

<img src="https://fs.linkmeup.ru/images/articles/buffers/juniper_hmc.png" width="500">
<i><a href="https://forums.juniper.net/t5/Enterprise-Cloud-and/Not-all-deep-buffer-switches-are-created-equal/ba-p/318393" target="_blank">Источник</a></i>.

Фото чипа ZX EXPRESS:
<img src="https://fs.linkmeup.ru/images/articles/buffers/zx_asic.png" width="500">
<i><a href="https://senetsy.ru/upload/juniper-summit-2019/New_in_Routing_and_%20Switching_Andrey_Pinaev_Juniper.pdf" target="_blank">Источник</a>.</i>

А вот так выглядит сетевой процессор Cisco с внешней памятью:

<img src="https://fs.linkmeup.ru/images/articles/buffers/cisco_npu.jpg" width="400">
<i><a href="https://servernews.ru/958639" target="_blank">Источник</a></i>.

Перечислять можно и дальше.
Что здесь важно отметить, что внешняя память тоже не даётся бесплатно. Во-первых, цена таких решений значительно выше. Во-вторых, пропускная способность обычно ниже.   И основное ограничение - канал между чипом коммутации и чипом памяти. Для производимых массово чипов, вроде GDDR5 полоса не превышает 900ГБ в режиме half-duplex. Но это чип, явно не заточенный под задачи сетевых сервисов.

Кастомный джуниперовский HMC <a href="https://forums.juniper.net/t5/Enterprise-Cloud-and/Not-all-deep-buffer-switches-are-created-equal/ba-p/318393">обещает</a> 1,25 Тб/с в обоих направлениях.

Если верить <a href="https://en.wikipedia.org/wiki/High_Bandwidth_Memory#HBM2">вики</a>, то HBM 2-го поколения, используемый в последнем чипе Broadcom Jericho2, выдаёт порядка 2Тб/с.

Но это всё ещё далеко от реальной производительности сетевого ASIC. Фактически шины до этой внешней памяти является узким местом, которое и определяет производительность чипа.
<hr>

<a name="HYBRID_BUFFERING"></a>
<h2>Hybrid Buffering</h2>
Поэтому почти все вендоры сегодня практикуют <b>гибридную буферизацию</b>, или, если хотите - динамическую. В нормальных условиях используется только on-chip память, предоставляющая line-rate производительность. А в случае перегрузки пакеты автоматически начинают буферизироваться во внешней памяти.
Это позволяет уменьшить стандартные задержки, энергопотребление и в большинстве случаев вписаться в ограниченную полосу пропускания до памяти.



<img src="https://fs.linkmeup.ru/images/articles/buffers/hybrid_buffering.png" width="800">
<i><a href="https://people.ucsc.edu/~warner/Bufs/CSG-DNX-Switching-J2%20Feb%2016%202018.pdf" target="_blank">Источник</a></i>.

<blockquote>
    Данный параграф отменяет сказанное выше о том, что on-chip памяти не хватит для VOQ. Фактически в случае гибридной буферизации она всё же дробится на тысячи очередей очень маленькой длины, чтобы обеспечить VOQ. Просто в нормальных условиях этой длины хватает, чтобы пропускать трафик мимо внешней памяти. 
    При этом в первую очередь начнёт офлоадиться на внешнюю память массивный трафик, идущий в низкоприоритетных очередях, а требовательный к задержками будет по-прежнему пролетать фаст-пасом.
</blockquote>

<hr>

<a name="TRUE_EVIL"></a>
<h2>Большие буферы - добро или зло?</h2>
В целом это довольно старая дилемма. Подольше похранить или пораньше дропнуть?

Конечно, всем приложениям хочется lossless low-latency сеть. Даже жирному некрасивому торренту. Но так не бывает и кем-то нужно жертвовать.
И мы долгое время живём с инертной мыслью , что часть приложений могут потерпеть задержки, а вот терять трафик совсем не хочется. Не в малой степени этому способствовало и то, что потери - это измеримая характеристика с более или менее понятными границами - потерь быть не должно. А что задержка? Вроде можно чётко сказать, что единицы миллисекунд - это хорошо, а секунды - это плохо. А между ними - зона спекуляций. Как оценить влияние вариаций задержки для рядового TCP-трафика?
Поэтому и спрос на устройства с большими буферами есть - никто не хочет терять трафик.

А теперь я выскажу не самое популярное мнение - потери - это хорошо. 
Так уж вышло, что один из транспортных протоколов, фиксирует перегрузки, опираясь на потери. 
Дроп в очереди на сетевом устройстве означает, что на нём случился затор - это он не по своему капризу. И будет совсем не лишним, если отправители немного приуменьшат свои congestion window.
Именно так и работают все классические (и не очень) реализации TCP Congestion Control. 
Соответственно на устройствах с глубокими буферами во время заторов пакеты будут долго копиться, не отбрасываясь. Когда они всё-таки дойдут до получателя и тот их ACKнет, отправитель не только не снизит скорость, но может даже её увеличить, если у него сейчас режим Slow Start или Congestion Avoidance. 
Можно взглянуть и дальше: растущая очередь взвинчивает RTT, что соответственно влечёт за собой увеличение RTO таймеров на отправителях, тем самым замедляя обнаружение потерь. 
То есть сеть лишается своего практически единственного инструмента управления перегрузками.
И таким образом архитекторы, пытающиеся решить вопрос заторов на сети путём увеличения буферов, усугубляют ситуацию ещё больше.

Ситуация, описанная выше, называется <b>bufferbloat</b> - распухание буфера.
Википедия иронично замечает:
<blockquote>
    Проект www.bufferbloat.net иронично определил этот термин, как «ухудшение производительности Интернета, вызванное предыдущими попытками её улучшения»
</blockquote>

Отбросы - санитары сети. Ко всеобщему удивлению, уменьшение очереди до одного пакета зачастую может кардинально улучшить ситуацию, особенно в условиях датацентра (только не сочтите это за дельный совет).

<blockquote>
    Справедливости ради следует заметить, что современные реализации TCP - BBR2, TIMELY ориентируются не только и не столько на потери, сколько на RTT и <a href="https://en.wikipedia.org/wiki/Bandwidth-delay_product" target="_blank">BDP</a>.
    Гугловый QUIC - надстройку над UDP - следует отнести сюда же. 
</blockquote>

Внутри фабрики датацентра RTT ультракороткий - зачастую меньше 1 мс. Это позволяет среагировать на потерю очень быстро и купировать перегрузку в её зачатке.
Собственно поэтому практически все ASIC'и для датацентровых коммутаторов имеют только крохотную on-chip память.
Хотя и появилась в последние годы тенденция к глубоких буферам и тут.
И этому даже находится <a href="https://forums.juniper.net/t5/Enterprise-Cloud-and/Not-all-deep-buffer-switches-are-created-equal/ba-p/318393" target="_blank">объяснение</a>.
<hr>

Особая история на границе датацентра (или на устройствах доступа в сети провайдера или на магистральных сетях).
<b>Во-первых</b>, это места, которые обычно заведомо строятся с переподпиской, поскольку WAN-линки дорогие, что автоматически означает, что ситуации, в которых трафика приходит больше, чем способен переварить интерфейс, ожидаемы. А значит нужна возможность пакеты хранить и обрабатывать их в соответствии с приоритетами. Большие буферы позволяют сгладить всплески.
<b>Во-вторых</b>, обычно приложения настолько чувствительные к задержкам, никто не будет пытаться растягивать на этот сегмент. Например, RoCE или распределённое хранилище. Для чуть менее чувствительных, таких как телефония, в больших буферах выделяется приоритетная очередь. 
<b>В-третьих</b>, тут задержки на устройстве всё ещё делают основной вклад в общее время доставки, но уже не настолько драматический.

Итак, устройства с большим объёмом памяти годятся в места где заложена переподписка или могут появиться заторы.

Что стоит отметить, так это то, что в датацентрах тоже есть ситуации, в которых 16-64 МБ буферов может не хватить, даже несмотря на отсутствие переподписки.
Два типичных примера - это обработка Big Data и Storage. 

<b>Анализ Big Data</b>. Кластера Map-Reduce - это сотни и тысячи машин, которые перемалывают параллельно огромные массивы данных по заданию Master-узла, заканчивают примерно одинаково и все разом начинают возвращать ответы на Master-узел. Ситуация называется <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.447.1375&rep=rep1&type=pdf">Incast</a>. Длится она порядка нескольких десятков миллисекунд и потом исчезает. 
On-chip память неспособна вместить эти данные - значит будет много дропов, значит ретрансмиты, значит общее снижение производительности.

<b>Storage</b>. Это штука крайне чувствительная к потерям и тоже гоняющая массивные объёмы данных. В случае хранилки тоже лучше не терять ничего. Но обычно она при этом и к задержкам предъявляет строгие требования, поэтому такие приложения обсудим <a href="#LLLL">пониже</a>.

Однако при этом крайне редко они единственные потребители сети в датацентрах, другим приложениям нужна низкая задержка.

Впрочем, это легко решается выделением очередей QoS с ограничением максимальной доступной глубины. И весь вопрос заключается тогда только в том, готова ли компания заплатить за глубокие буферы, возможно, не использовать их  и поддерживать конфигурацию QoS. 

Но в любой ситуации лучше следовать правилу: <a href="https://www.nextplatform.com/2019/07/23/the-switch-router-war-is-over-and-hyperscalers-won/">use shallow ASIC buffers when you can and use deep buffers when you must</a>.

<b>Критика глубоких буферов</b>: 

<ul>
    <li>
        <a href="https://packetpushers.net/aristas-big-buffer-b-s/" target="_blank">Arista’s Big Buffer B.S.</a>
    </li>
    <li>
        <a href="https://people.ucsc.edu/~warner/Bufs/incast.html" target="_blank">Incast</a>
    </li>
    <li>
        <a href="http://miercom.com/pdf/reports/20160210.pdf" target="_blank">Speeding Applications in Data Center Networks. The Interaction of Buffer Size and TCP Protocol Handling and its Impact on Data-Mining and Large Enterprise IT Traffic Flows</a>
    </li>
</ul>
<hr>
Кстати, показательная таблица типичных задержек:

<img src="https://fs.linkmeup.ru/images/articles/buffers/latencies.png" width="630">
<i><a href="https://people.ucsc.edu/~warner/Bufs/Buffering-WP_August_2017.pdf" target="_blank">Источник</a></i>.


<hr>

<a name="LLLL"></a>
<h1>Low-latency lossless сети</h1>
С развитием RoCE, RDMA, nVME over Fabric к сети стали появляться другие, неслыханные доселе требования: и каждый пакет ценен и времени терять нельзя. Одновременно. И хуже того, мы хотим по максимуму утилизировать имеющиеся линки, чтобы они не простаивали.
И все требования оправданы - осуждать их мы здесь не будем.

Так что же можно сделать? На самом деле, как я уже говорил выше, условия сети датацентра хороши тем, что информация о перегрузке очень быстро доносится до отправителей. Поэтому и реакция на потерянный пакет не заставит себя долго ждать.

Но что если нам не отбрасывать пакет, а каким-то другим способом сообщить отправителю, что нужно замедлиться? 
Здесь есть несколько конкурирующих подходов.

ECN-Based
Bandwidth-Delay Product Based
RTT-BASED


<h2>ECN-Based</h2>
Транзитное устройство, говтовящееся испытать перегрузку, явным образом сообщает отправителям о том, что нужно охладить свою страсть.

Прозорливые инженеры заложили в IP целых 8 бит под QoS, и только 6 мы задействовали под DSCP, а 2 бита были зарезервированы для целей <b>ECN - Explicit Congestion Notification</b>.

Надолго забытый механизм сегодня извлекают из ящика стола, сдувают с него пыль, и вставляют в шкатулку, на которой нацарапано или <a href="https://tools.ietf.org/html/rfc8257" target="_blank">DCTCP</a>

Транзитное устройство при заполнении буфера больше, чем до определённого порога, выставляет в заголовках IP обрабатываемых пакетов бит CE (Congestion Encountered) и отправляет пакет дальше.
Получатель, увидев в пришедшем пакете этот флаг, сообщает отправителю о перегрузке и о том, что нужно снизить скорость.

Классический TCP может обнаружить только уже существующую перегрузку, а DCTCP, используя ECN, узнаёт о том, что она только приближается, и пробует её избежать. 

Есть и другие реализации TCP, поддерживающие ECN, например, HTCP.

Нюанс с ECN-based Congestion Control механизмами в том, что до поры до времени они ничего не знают о надвигающейся перегрузке, а потом должен пройти ещё целый RTT, чтобы отправитель узнал, что какое-то транзитное устройство к ней близко. К тому времени, как отправители начнут снижать скорость, перегрузка уже может или рассосаться или наоборот дойти до уровня, когда начнутся дропы. 


<h2>Bandwidth-Delay Product Based</h2>
Другие реализации замеряют эффективную полосу сети совместно с RTT, то есть сколько можно ещё напихать в трубу до того, как это создаст затор и увеличит задержку.

Примерами таких протоколов являются <a href="https://habr.com/ru/post/322430/" target="_blank">BBR</a> и <a href="https://www.hamilton.ie/net/draft-leith-tcp-htcp-00.txt" target="_blank">H-TCP</a>.

<h2>RTT-BASED</h2>
В конце концов есть элегантные механизмы, которые замеряют время прохода трафика туда-обратно.
Идея провальная для MAN/WAN-сегментов, и, честно говоря, при попытке программной вычисления RTT тоже.
TIMELY от Google с аппаратным offload'ом вычисления RTT один из наиболее удачных примеров.

На самом деле, если бы не видео с прекрасной девушкой, рассказывающей про технические детали TIMELY, не знаю даже стал ли бы я упоминать про него. Наслаждайтесь, но берегите уши: <a href="https://dl.acm.org/action/downloadSupplement?doi=10.1145%2F2829988.2787510&file=p537-mittal.webm&download=true" target="_blank">TIMELY: RTT-based Congestion Control for the Datacenter</a>.
<hr>

<a name="LINKS"></a>
<h1>Полезные ссылки</h1>
В этот раз хоть под кат убирай. Но, поверьте, я оставил тут только самые хорошие источники, прочитанные лично моими глазами и отобранные лично моими руками.

<ul>
    <li><b>Архитектура памяти</b>
    <ul>
        <li>
            <a href="https://people.ucsc.edu/~warner/buffer.html" target="_blank">Packet Buffers</a>. Отсюда по ссылкам разворачиваются разнообразные материалы очень глубоко
        </li>
        <li>
            <a href="https://people.ucsc.edu/~warner/Bufs/Buffering-WP_August_2017.pdf" target="_blank">An Update on Router Buffering</a>
        </li>
        <li>
            <a href="https://xrdocs.io/ncs5500/blogs/2018-05-07-ncs-5500-buffering-architecture/" target="_blank">NCS 5500 Buffering Architecture</a>
        </li>
        <li>
            <a href="https://www.cisco.com/c/en/us/products/collateral/switches/nexus-5020-switch/white_paper_c11-465436.html" target="_blank">Cisco Nexus 5000 Series Switches</a>. Cut-through and Store-and-Forward
        </li>
        <li>
            <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/cos-qfx-series-congestion-notification-understanding.html#jd0e554" target="_blank">Understanding CoS Flow Control (Ethernet PAUSE and PFC)</a>
        </li>
        <li>
            <a href="https://github.com/Mellanox/mlxsw/wiki/Quality-of-Service" target="_blank">Quality of Service</a>. Headroom buffers
        </li>
    </ul>
    </li>
    <li>
    <b>Реализации очередей</b>
    <ul>
        <li>
            <a href="https://archive.nanog.org/sites/default/files/wednesday_tutorial_szarecki_packet-buffering.pdf" target="_blank">Strategies of packet buffering inside Routers</a>
        </li>
        <li>
            <a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/cos-qfx-series-voq-understanding.html" target="_blank">Understanding CoS Virtual Output Queues (VOQs) on QFX10000 Switches</a>
        </li>

        <li>
            <a href="https://forums.juniper.net/t5/forums/recentpostspage/post-type/message/category-id/Blogs/user-id/101479" target="_blank">What is VOQ and why you should care?</a>
        </li>
    </ul>
    </li>
    <li>
    <b>Deep Buffers</b>
    <ul>    
        <li>
            <a href="https://forums.juniper.net/t5/Enterprise-Cloud-and/Not-all-deep-buffer-switches-are-created-equal/ba-p/318393" target="_blank">Not all deep buffer switches are created equal</a>
        </li>
        <li>
            <a href="https://packetpushers.net/aristas-big-buffer-b-s/" target="_blank">Arista’s Big Buffer B.S.</a>
        </li>
        <li>
            <a href="http://miercom.com/pdf/reports/20160210.pdf" target="_blank">Speeding Applications in Data Center Networks. The Interaction of Buffer Size and TCP Protocol Handling and its Impact on Data-Mining and Large Enterprise IT Traffic Flows</a>
        </li>
    </ul>
    </li>
    <li>
        <a href="https://tools.ietf.org/html/rfc8257" target="_blank">Data Center TCP (DCTCP): TCP Congestion Control for Data Centers</a>
    </li>
    <li>
        <a href="https://support.huawei.com/enterprise/en/doc/EDOC1100086962" target="_blank">Understanding Microburst</a>
    </li>
</ul>
<hr>

<h1>Заключение</h1>
Я предпринял несколько попыток написать короткое резюме всей статье, но каждый раз получалось почти полное её переписывание иными словами.
Поэтому просто замечу, что буферы - это неотъемлемая часть сетевого устройства. Но к тому же это место, где ко времени жизни пакетов могут добавиться лишние миллисекунды. И чем больше объём памяти, тем дольше трафик может в ней протомиться. Но даже в экстремальных случаях (8-игиговый буфер) нужно с большим подозрением и узкими глазами относиться к претензиям к сети о том, что, мол, у кого-то секундные задержки в пределах датацентра - ну негде там столько их хранить.
Вопрос большие или маленьки буферы обычно решается легко, когда отталкиваешься от задач и от позиции устройства в сети, но есть, конечно, места, где это вопрос философии или даже религии. 

<hr>

<h1>Спасибы</h1>
<ul>
    <li>Андрею Глазкову за рецензию и дельные замечания, Shared Buffers и коммерческих чипах</li>
    <li>Михаилу Соколову за разъяснения об устройстве чипов, SerDes и Silicon Photonics</li>
    <li>Александру Клименко за обнаружение точек роста в вопросах Admission Control, Alpha, Pipeline'ов и минусов DCTCP</li>
    <li>Александру Азимову за комментарии о Lossless Ethernet</li>
    <li>Артёму Чернобаю за КДПВ</li>
</ul>
